"""Export Service.

Handles document export to various formats and distribution.
"""
from __future__ import annotations

import base64
import io
import logging
import secrets
import uuid
import zipfile
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Optional

from backend.app.services.config import get_settings

logger = logging.getLogger(__name__)


def _now() -> datetime:
    return datetime.now(timezone.utc)


class ExportService:
    """Service for exporting documents to various formats."""

    def __init__(self):
        self._export_jobs: dict[str, dict] = {}
        self._embed_tokens: dict[str, dict] = {}
        base_root = get_settings().uploads_root
        self._uploads_dir = base_root / "exports"
        self._uploads_dir.mkdir(parents=True, exist_ok=True)

    async def export_to_pdf(
        self,
        content: bytes,
        options: dict[str, Any],
    ) -> bytes:
        """Export content to PDF format."""
        # If already PDF, apply options
        if options.get("pdfa_compliant"):
            return await self._convert_to_pdfa(content, options)
        return content

    async def _convert_to_pdfa(
        self,
        pdf_content: bytes,
        options: dict[str, Any],
    ) -> bytes:
        """Convert PDF to PDF/A format for archival."""
        try:
            import fitz
            doc = fitz.open(stream=pdf_content, filetype="pdf")
            # Add PDF/A metadata
            metadata = doc.metadata
            metadata["format"] = "PDF/A-1b"
            doc.set_metadata(metadata)
            output = io.BytesIO()
            doc.save(output)
            doc.close()
            return output.getvalue()
        except ImportError:
            logger.warning("PyMuPDF not available, returning original PDF")
            return pdf_content

    async def export_to_docx(
        self,
        content: str,
        options: dict[str, Any],
    ) -> bytes:
        """Export content to Word DOCX format."""
        try:
            from docx import Document
            from docx.shared import Inches, Pt

            doc = Document()

            # Add title if provided
            if options.get("title"):
                doc.add_heading(options["title"], 0)

            # Add content paragraphs
            for para in content.split("\n\n"):
                if para.strip():
                    doc.add_paragraph(para.strip())

            # Save to bytes
            output = io.BytesIO()
            doc.save(output)
            return output.getvalue()

        except ImportError:
            logger.warning("python-docx not available")
            raise ImportError("python-docx is required for DOCX export")

    async def export_to_pptx(
        self,
        content: str,
        options: dict[str, Any],
    ) -> bytes:
        """Export content to PowerPoint PPTX format."""
        try:
            from pptx import Presentation
            from pptx.util import Inches, Pt

            prs = Presentation()

            # Add title slide
            title_slide_layout = prs.slide_layouts[0]
            slide = prs.slides.add_slide(title_slide_layout)
            title = slide.shapes.title
            subtitle = slide.placeholders[1]

            title.text = options.get("title", "Document Export")
            subtitle.text = options.get("subtitle", "Generated by NeuraReport")

            # Add content slides
            bullet_slide_layout = prs.slide_layouts[1]
            sections = content.split("\n\n")

            for i, section in enumerate(sections):
                if not section.strip():
                    continue

                slide = prs.slides.add_slide(bullet_slide_layout)
                shapes = slide.shapes
                title_shape = shapes.title
                body_shape = shapes.placeholders[1]

                title_shape.text = f"Section {i + 1}"

                tf = body_shape.text_frame
                tf.text = section.strip()

            # Save to bytes
            output = io.BytesIO()
            prs.save(output)
            return output.getvalue()

        except ImportError:
            logger.warning("python-pptx not available")
            raise ImportError("python-pptx is required for PPTX export")

    async def export_to_epub(
        self,
        content: str,
        options: dict[str, Any],
    ) -> bytes:
        """Export content to ePub format."""
        try:
            from ebooklib import epub

            book = epub.EpubBook()

            # Set metadata
            book.set_identifier(str(uuid.uuid4()))
            book.set_title(options.get("title", "Document Export"))
            book.set_language(options.get("language", "en"))

            if options.get("author"):
                book.add_author(options["author"])

            # Create chapter
            chapter = epub.EpubHtml(
                title="Content",
                file_name="content.xhtml",
                lang="en",
            )
            chapter.content = f"<html><body><h1>{options.get('title', 'Document')}</h1>{content}</body></html>"
            book.add_item(chapter)

            # Add navigation
            book.toc = [epub.Link("content.xhtml", "Content", "content")]
            book.add_item(epub.EpubNcx())
            book.add_item(epub.EpubNav())

            book.spine = ["nav", chapter]

            # Write to bytes
            output = io.BytesIO()
            epub.write_epub(output, book)
            return output.getvalue()

        except ImportError:
            logger.warning("ebooklib not available")
            raise ImportError("ebooklib is required for ePub export")

    async def export_to_latex(
        self,
        content: str,
        options: dict[str, Any],
    ) -> bytes:
        """Export content to LaTeX format."""
        doc_class = options.get("document_class", "article")
        title = options.get("title", "Document")
        author = options.get("author", "")

        latex_content = f"""\\documentclass{{{doc_class}}}
\\usepackage[utf8]{{inputenc}}
\\usepackage{{graphicx}}
\\usepackage{{hyperref}}

\\title{{{title}}}
\\author{{{author}}}
\\date{{\\today}}

\\begin{{document}}

\\maketitle

{content}

\\end{{document}}
"""
        return latex_content.encode("utf-8")

    async def export_to_markdown(
        self,
        content: str,
        options: dict[str, Any],
    ) -> bytes:
        """Export content to Markdown format."""
        flavor = options.get("flavor", "gfm")
        include_frontmatter = options.get("include_frontmatter", True)

        md_content = ""

        if include_frontmatter:
            md_content = f"""---
title: {options.get('title', 'Document')}
author: {options.get('author', '')}
date: {_now().strftime('%Y-%m-%d')}
---

"""

        md_content += content

        return md_content.encode("utf-8")

    async def export_to_html(
        self,
        content: str,
        options: dict[str, Any],
    ) -> bytes:
        """Export content to HTML format."""
        title = options.get("title", "Document")
        standalone = options.get("standalone", True)

        if standalone:
            html_content = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{title}</title>
    <style>
        body {{ font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }}
        h1 {{ color: #333; }}
        p {{ line-height: 1.6; }}
    </style>
</head>
<body>
    <h1>{title}</h1>
    {content}
</body>
</html>
"""
        else:
            html_content = content

        return html_content.encode("utf-8")

    async def create_export_job(
        self,
        document_id: str,
        format: str,
        options: dict[str, Any],
    ) -> dict:
        """Create an export job."""
        job_id = str(uuid.uuid4())
        now = _now()

        job = {
            "job_id": job_id,
            "document_id": document_id,
            "format": format,
            "options": options,
            "status": "pending",
            "created_at": now,
            "completed_at": None,
            "download_url": None,
            "file_size": None,
            "error": None,
        }

        self._export_jobs[job_id] = job

        # Persist to state store
        try:
            from backend.app.repositories.state.store import state_store
            with state_store.transaction() as state:
                state["export_jobs"][job_id] = job
        except Exception as e:
            logger.warning(f"Failed to persist export job: {e}")

        return job

    async def get_export_job(self, job_id: str) -> Optional[dict]:
        """Get export job status."""
        return self._export_jobs.get(job_id)

    async def bulk_export(
        self,
        document_ids: list[str],
        format: str,
        options: dict[str, Any],
    ) -> dict:
        """Export multiple documents as a ZIP file."""
        job_id = str(uuid.uuid4())
        now = _now()

        # Create ZIP file in memory
        zip_buffer = io.BytesIO()

        with zipfile.ZipFile(zip_buffer, "w", zipfile.ZIP_DEFLATED) as zf:
            for i, doc_id in enumerate(document_ids):
                # Add placeholder files
                filename = f"document_{i + 1}.{format}"
                zf.writestr(filename, f"Content of document {doc_id}")

        zip_content = zip_buffer.getvalue()

        # Save ZIP file
        zip_filename = f"export_{job_id}.zip"
        zip_path = self._uploads_dir / zip_filename
        zip_path.write_bytes(zip_content)

        job = {
            "job_id": job_id,
            "document_ids": document_ids,
            "format": format,
            "status": "completed",
            "created_at": now,
            "completed_at": _now(),
            "download_url": f"/uploads/exports/{zip_filename}",
            "file_size": len(zip_content),
        }

        self._export_jobs[job_id] = job

        return job

    async def generate_embed_token(
        self,
        document_id: str,
        options: dict[str, Any],
    ) -> dict:
        """Generate an embed token for a document."""
        token = secrets.token_urlsafe(32)
        now = _now()

        embed_data = {
            "token": token,
            "document_id": document_id,
            "options": options,
            "created_at": now,
            "expires_at": None,  # Could add expiration
        }

        self._embed_tokens[token] = embed_data

        # Generate embed URL and code
        embed_url = f"/embed/{token}"
        width = options.get("width", 800)
        height = options.get("height", 600)

        embed_code = f'<iframe src="{embed_url}" width="{width}" height="{height}" frameborder="0"></iframe>'

        return {
            "token": token,
            "embed_url": embed_url,
            "embed_code": embed_code,
            "expires_at": embed_data["expires_at"],
        }

    async def validate_embed_token(self, token: str) -> Optional[dict]:
        """Validate an embed token."""
        return self._embed_tokens.get(token)


class DistributionService:
    """Service for distributing documents to various channels."""

    def __init__(self):
        self._distribution_jobs: dict[str, dict] = {}

    async def send_email(
        self,
        document_id: str,
        recipients: list[str],
        subject: str,
        message: str,
        attachments: list[bytes] = None,
    ) -> dict:
        """Send document via email."""
        job_id = str(uuid.uuid4())
        now = _now()

        # Email sending would be implemented here
        # Using existing mailer service if available

        job = {
            "job_id": job_id,
            "channel": "email",
            "document_id": document_id,
            "recipients": recipients,
            "status": "sent",
            "sent_at": now,
            "recipients_count": len(recipients),
        }

        self._distribution_jobs[job_id] = job

        logger.info(f"Email sent to {len(recipients)} recipients")

        return job

    async def send_to_slack(
        self,
        document_id: str,
        channel: str,
        message: Optional[str] = None,
        file_content: Optional[bytes] = None,
    ) -> dict:
        """Send document to Slack channel."""
        job_id = str(uuid.uuid4())
        now = _now()

        try:
            from slack_sdk import WebClient

            # Would need SLACK_BOT_TOKEN environment variable
            import os
            token = os.getenv("SLACK_BOT_TOKEN")

            if token:
                client = WebClient(token=token)

                if file_content:
                    client.files_upload_v2(
                        channel=channel,
                        content=file_content,
                        title=f"Document {document_id}",
                        initial_comment=message or "Document shared from NeuraReport",
                    )
                else:
                    client.chat_postMessage(
                        channel=channel,
                        text=message or f"Document {document_id} shared from NeuraReport",
                    )

                status = "sent"
            else:
                status = "skipped"
                logger.warning("Slack token not configured")

        except ImportError:
            status = "error"
            logger.warning("slack_sdk not available")
        except Exception as e:
            status = "error"
            logger.error(f"Slack send failed: {e}")

        job = {
            "job_id": job_id,
            "channel": "slack",
            "document_id": document_id,
            "slack_channel": channel,
            "status": status,
            "sent_at": now,
        }

        self._distribution_jobs[job_id] = job

        return job

    async def send_to_teams(
        self,
        document_id: str,
        webhook_url: str,
        title: Optional[str] = None,
        message: Optional[str] = None,
    ) -> dict:
        """Send document to Microsoft Teams via webhook."""
        job_id = str(uuid.uuid4())
        now = _now()

        try:
            import aiohttp

            payload = {
                "@type": "MessageCard",
                "@context": "http://schema.org/extensions",
                "themeColor": "0076D7",
                "summary": title or f"Document {document_id}",
                "sections": [
                    {
                        "activityTitle": title or "Document Shared",
                        "text": message or f"Document {document_id} shared from NeuraReport",
                    }
                ],
            }

            async with aiohttp.ClientSession() as session:
                async with session.post(webhook_url, json=payload) as resp:
                    if resp.status == 200:
                        status = "sent"
                    else:
                        status = "error"
                        logger.warning(f"Teams webhook returned {resp.status}")

        except Exception as e:
            status = "error"
            logger.error(f"Teams send failed: {e}")

        job = {
            "job_id": job_id,
            "channel": "teams",
            "document_id": document_id,
            "status": status,
            "sent_at": now,
        }

        self._distribution_jobs[job_id] = job

        return job

    async def send_webhook(
        self,
        document_id: str,
        webhook_url: str,
        method: str = "POST",
        headers: dict[str, str] = None,
        payload: dict = None,
    ) -> dict:
        """Send document data via webhook."""
        job_id = str(uuid.uuid4())
        now = _now()

        try:
            import aiohttp

            if payload is None:
                payload = {
                    "document_id": document_id,
                    "timestamp": now.isoformat(),
                    "source": "neura_report",
                }

            async with aiohttp.ClientSession() as session:
                async with session.request(
                    method,
                    webhook_url,
                    json=payload,
                    headers=headers,
                ) as resp:
                    status = "sent" if resp.status < 400 else "error"
                    response_status = resp.status

        except Exception as e:
            status = "error"
            response_status = None
            logger.error(f"Webhook send failed: {e}")

        job = {
            "job_id": job_id,
            "channel": "webhook",
            "document_id": document_id,
            "webhook_url": webhook_url,
            "status": status,
            "response_status": response_status,
            "sent_at": now,
        }

        self._distribution_jobs[job_id] = job

        return job

    async def publish_to_portal(
        self,
        document_id: str,
        portal_path: str,
        options: dict[str, Any],
    ) -> dict:
        """Publish document to portal."""
        job_id = str(uuid.uuid4())
        now = _now()

        # Portal publishing would be implemented here
        portal_url = f"/portal/{portal_path}/{document_id}"

        job = {
            "job_id": job_id,
            "channel": "portal",
            "document_id": document_id,
            "portal_path": portal_path,
            "portal_url": portal_url,
            "public": options.get("public", False),
            "status": "published",
            "published_at": now,
        }

        self._distribution_jobs[job_id] = job

        return job


# Singleton instances
export_service = ExportService()
distribution_service = DistributionService()
