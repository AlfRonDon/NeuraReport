{
  "datasets": {
    "header": {
      "description": "Scalar header values: reporting period boundaries passed as user parameters, and a server-generated timestamp for the generation time.",
      "columns": [
        "date_from",
        "date_to",
        "generated_at"
      ]
    },
    "rows": {
      "description": "One row per job run from app_job_runs within the selected date range, containing job identity, timing, throughput, latency, and error metrics.",
      "columns": [
        "row_job_id",
        "row_started_at",
        "row_stopped_at",
        "row_duration_ms",
        "row_rows",
        "row_read_lat_avg",
        "row_write_lat_avg",
        "row_error_pct"
      ],
      "grouping": [],
      "ordering": [
        "started_at ASC"
      ]
    },
    "totals": {
      "description": "No totals section required for this report.",
      "columns": []
    }
  },
  "semantics": "date_from and date_to are required user-supplied filter parameters that bound the reporting period. They are passed through as display values in the header and used as filters on app_job_runs.started_at. generated_at is a server-side runtime value injected at render time and is not sourced from the database.",
  "parameters": {
    "required": [
      {
        "name": "date_from",
        "type": "date"
      },
      {
        "name": "date_to",
        "type": "date"
      }
    ],
    "optional": []
  },
  "transformations": [
    "No reshape required â€” single table app_job_runs, one row per job run.",
    "Filter app_job_runs.started_at to rows where started_at is between date_from and date_to parameters.",
    "Format row_started_at and row_stopped_at as datetime strings (%Y-%m-%d %H:%M:%S).",
    "Format row_read_lat_avg and row_write_lat_avg to 4 decimal places.",
    "Format row_error_pct to 2 decimal places.",
    "Order rows by started_at ascending."
  ]
}