/* tslint:disable */
/* eslint-disable */
/**
 * NeuraReport API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 4.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, replaceWithSerializableTypeIfNeeded } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { BackendAppApiRoutesSearchSearchRequest } from '../models';
// @ts-ignore
import type { HTTPValidationError } from '../models';
// @ts-ignore
import type { IndexDocumentRequest } from '../models';
// @ts-ignore
import type { SaveSearchRequest } from '../models';
// @ts-ignore
import type { SearchReplaceRequest } from '../models';
/**
 * SearchApi - axios parameter creator
 */
export const SearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Perform boolean search with AND, OR, NOT operators.  Returns:     SearchResponse with boolean match results
         * @summary Boolean Search
         * @param {BackendAppApiRoutesSearchSearchRequest} backendAppApiRoutesSearchSearchRequest 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        booleanSearchApiV1SearchSearchBooleanPost: async (backendAppApiRoutesSearchSearchRequest: BackendAppApiRoutesSearchSearchRequest, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'backendAppApiRoutesSearchSearchRequest' is not null or undefined
            assertParamExists('booleanSearchApiV1SearchSearchBooleanPost', 'backendAppApiRoutesSearchSearchRequest', backendAppApiRoutesSearchSearchRequest)
            const localVarPath = `/api/v1/search/search/boolean`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(backendAppApiRoutesSearchSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a saved search.
         * @summary Delete Saved Search
         * @param {string} searchId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSavedSearchApiV1SearchSavedSearchesSearchIdDelete: async (searchId: string, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchId' is not null or undefined
            assertParamExists('deleteSavedSearchApiV1SearchSavedSearchesSearchIdDelete', 'searchId', searchId)
            const localVarPath = `/api/v1/search/saved-searches/{search_id}`
                .replace(`{${"search_id"}}`, encodeURIComponent(String(searchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find documents similar to the given document.  Returns:     List of similar documents
         * @summary Find Similar Documents
         * @param {string} documentId 
         * @param {number} [limit] 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSimilarDocumentsApiV1SearchDocumentsDocumentIdSimilarGet: async (documentId: string, limit?: number, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('findSimilarDocumentsApiV1SearchDocumentsDocumentIdSimilarGet', 'documentId', documentId)
            const localVarPath = `/api/v1/search/documents/{document_id}/similar`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single saved search by ID.  Returns:     SavedSearch configuration
         * @summary Get Saved Search
         * @param {string} searchId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSavedSearchApiV1SearchSavedSearchesSearchIdGet: async (searchId: string, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchId' is not null or undefined
            assertParamExists('getSavedSearchApiV1SearchSavedSearchesSearchIdGet', 'searchId', searchId)
            const localVarPath = `/api/v1/search/saved-searches/{search_id}`
                .replace(`{${"search_id"}}`, encodeURIComponent(String(searchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get search analytics.
         * @summary Get Search Analytics
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearchAnalyticsApiV1SearchAnalyticsGet: async (xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/search/analytics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get available search types.  Returns:     List of search types with descriptions
         * @summary Get Search Types
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearchTypesApiV1SearchTypesGet: async (xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/search/types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Index a document for searching.  Returns:     Success status
         * @summary Index Document
         * @param {IndexDocumentRequest} indexDocumentRequest 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexDocumentApiV1SearchIndexPost: async (indexDocumentRequest: IndexDocumentRequest, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'indexDocumentRequest' is not null or undefined
            assertParamExists('indexDocumentApiV1SearchIndexPost', 'indexDocumentRequest', indexDocumentRequest)
            const localVarPath = `/api/v1/search/index`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(indexDocumentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all saved searches.
         * @summary List Saved Searches
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSavedSearchesApiV1SearchSavedSearchesGet: async (xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/search/saved-searches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Perform regex pattern search.  Returns:     SearchResponse with regex matches  Raises:     HTTPException 400: If regex pattern is invalid or potentially dangerous
         * @summary Regex Search
         * @param {BackendAppApiRoutesSearchSearchRequest} backendAppApiRoutesSearchSearchRequest 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regexSearchApiV1SearchSearchRegexPost: async (backendAppApiRoutesSearchSearchRequest: BackendAppApiRoutesSearchSearchRequest, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'backendAppApiRoutesSearchSearchRequest' is not null or undefined
            assertParamExists('regexSearchApiV1SearchSearchRegexPost', 'backendAppApiRoutesSearchSearchRequest', backendAppApiRoutesSearchSearchRequest)
            const localVarPath = `/api/v1/search/search/regex`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(backendAppApiRoutesSearchSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reindex all documents in the search index.  Returns:     Reindex job status
         * @summary Reindex All
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reindexAllApiV1SearchIndexReindexPost: async (xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/search/index/reindex`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a document from the search index.  Returns:     Success status
         * @summary Remove From Index
         * @param {string} documentId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFromIndexApiV1SearchIndexDocumentIdDelete: async (documentId: string, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('removeFromIndexApiV1SearchIndexDocumentIdDelete', 'documentId', documentId)
            const localVarPath = `/api/v1/search/index/{document_id}`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Run a saved search.
         * @summary Run Saved Search
         * @param {string} searchId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runSavedSearchApiV1SearchSavedSearchesSearchIdRunPost: async (searchId: string, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchId' is not null or undefined
            assertParamExists('runSavedSearchApiV1SearchSavedSearchesSearchIdRunPost', 'searchId', searchId)
            const localVarPath = `/api/v1/search/saved-searches/{search_id}/run`
                .replace(`{${"search_id"}}`, encodeURIComponent(String(searchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Save a search for later use.  Returns:     SavedSearch configuration
         * @summary Save Search
         * @param {SaveSearchRequest} saveSearchRequest 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveSearchApiV1SearchSavedSearchesPost: async (saveSearchRequest: SaveSearchRequest, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'saveSearchRequest' is not null or undefined
            assertParamExists('saveSearchApiV1SearchSavedSearchesPost', 'saveSearchRequest', saveSearchRequest)
            const localVarPath = `/api/v1/search/saved-searches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(saveSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search and replace across documents.  Returns:     Replacement results
         * @summary Search And Replace
         * @param {SearchReplaceRequest} searchReplaceRequest 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAndReplaceApiV1SearchSearchReplacePost: async (searchReplaceRequest: SearchReplaceRequest, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchReplaceRequest' is not null or undefined
            assertParamExists('searchAndReplaceApiV1SearchSearchReplacePost', 'searchReplaceRequest', searchReplaceRequest)
            const localVarPath = `/api/v1/search/search/replace`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchReplaceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Perform a search with various options.  Returns:     SearchResponse with results
         * @summary Search
         * @param {BackendAppApiRoutesSearchSearchRequest} backendAppApiRoutesSearchSearchRequest 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchApiV1SearchSearchPost: async (backendAppApiRoutesSearchSearchRequest: BackendAppApiRoutesSearchSearchRequest, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'backendAppApiRoutesSearchSearchRequest' is not null or undefined
            assertParamExists('searchApiV1SearchSearchPost', 'backendAppApiRoutesSearchSearchRequest', backendAppApiRoutesSearchSearchRequest)
            const localVarPath = `/api/v1/search/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(backendAppApiRoutesSearchSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Perform semantic similarity search.  Returns:     SearchResponse with semantically similar results
         * @summary Semantic Search
         * @param {BackendAppApiRoutesSearchSearchRequest} backendAppApiRoutesSearchSearchRequest 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        semanticSearchApiV1SearchSearchSemanticPost: async (backendAppApiRoutesSearchSearchRequest: BackendAppApiRoutesSearchSearchRequest, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'backendAppApiRoutesSearchSearchRequest' is not null or undefined
            assertParamExists('semanticSearchApiV1SearchSearchSemanticPost', 'backendAppApiRoutesSearchSearchRequest', backendAppApiRoutesSearchSearchRequest)
            const localVarPath = `/api/v1/search/search/semantic`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(backendAppApiRoutesSearchSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 */
export const SearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Perform boolean search with AND, OR, NOT operators.  Returns:     SearchResponse with boolean match results
         * @summary Boolean Search
         * @param {BackendAppApiRoutesSearchSearchRequest} backendAppApiRoutesSearchSearchRequest 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async booleanSearchApiV1SearchSearchBooleanPost(backendAppApiRoutesSearchSearchRequest: BackendAppApiRoutesSearchSearchRequest, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.booleanSearchApiV1SearchSearchBooleanPost(backendAppApiRoutesSearchSearchRequest, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.booleanSearchApiV1SearchSearchBooleanPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a saved search.
         * @summary Delete Saved Search
         * @param {string} searchId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSavedSearchApiV1SearchSavedSearchesSearchIdDelete(searchId: string, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSavedSearchApiV1SearchSavedSearchesSearchIdDelete(searchId, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.deleteSavedSearchApiV1SearchSavedSearchesSearchIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Find documents similar to the given document.  Returns:     List of similar documents
         * @summary Find Similar Documents
         * @param {string} documentId 
         * @param {number} [limit] 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findSimilarDocumentsApiV1SearchDocumentsDocumentIdSimilarGet(documentId: string, limit?: number, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findSimilarDocumentsApiV1SearchDocumentsDocumentIdSimilarGet(documentId, limit, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.findSimilarDocumentsApiV1SearchDocumentsDocumentIdSimilarGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a single saved search by ID.  Returns:     SavedSearch configuration
         * @summary Get Saved Search
         * @param {string} searchId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSavedSearchApiV1SearchSavedSearchesSearchIdGet(searchId: string, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSavedSearchApiV1SearchSavedSearchesSearchIdGet(searchId, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.getSavedSearchApiV1SearchSavedSearchesSearchIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get search analytics.
         * @summary Get Search Analytics
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSearchAnalyticsApiV1SearchAnalyticsGet(xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSearchAnalyticsApiV1SearchAnalyticsGet(xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.getSearchAnalyticsApiV1SearchAnalyticsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get available search types.  Returns:     List of search types with descriptions
         * @summary Get Search Types
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSearchTypesApiV1SearchTypesGet(xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSearchTypesApiV1SearchTypesGet(xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.getSearchTypesApiV1SearchTypesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Index a document for searching.  Returns:     Success status
         * @summary Index Document
         * @param {IndexDocumentRequest} indexDocumentRequest 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async indexDocumentApiV1SearchIndexPost(indexDocumentRequest: IndexDocumentRequest, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.indexDocumentApiV1SearchIndexPost(indexDocumentRequest, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.indexDocumentApiV1SearchIndexPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all saved searches.
         * @summary List Saved Searches
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSavedSearchesApiV1SearchSavedSearchesGet(xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSavedSearchesApiV1SearchSavedSearchesGet(xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.listSavedSearchesApiV1SearchSavedSearchesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Perform regex pattern search.  Returns:     SearchResponse with regex matches  Raises:     HTTPException 400: If regex pattern is invalid or potentially dangerous
         * @summary Regex Search
         * @param {BackendAppApiRoutesSearchSearchRequest} backendAppApiRoutesSearchSearchRequest 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regexSearchApiV1SearchSearchRegexPost(backendAppApiRoutesSearchSearchRequest: BackendAppApiRoutesSearchSearchRequest, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regexSearchApiV1SearchSearchRegexPost(backendAppApiRoutesSearchSearchRequest, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.regexSearchApiV1SearchSearchRegexPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Reindex all documents in the search index.  Returns:     Reindex job status
         * @summary Reindex All
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reindexAllApiV1SearchIndexReindexPost(xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reindexAllApiV1SearchIndexReindexPost(xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.reindexAllApiV1SearchIndexReindexPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove a document from the search index.  Returns:     Success status
         * @summary Remove From Index
         * @param {string} documentId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeFromIndexApiV1SearchIndexDocumentIdDelete(documentId: string, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeFromIndexApiV1SearchIndexDocumentIdDelete(documentId, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.removeFromIndexApiV1SearchIndexDocumentIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Run a saved search.
         * @summary Run Saved Search
         * @param {string} searchId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runSavedSearchApiV1SearchSavedSearchesSearchIdRunPost(searchId: string, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runSavedSearchApiV1SearchSavedSearchesSearchIdRunPost(searchId, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.runSavedSearchApiV1SearchSavedSearchesSearchIdRunPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Save a search for later use.  Returns:     SavedSearch configuration
         * @summary Save Search
         * @param {SaveSearchRequest} saveSearchRequest 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveSearchApiV1SearchSavedSearchesPost(saveSearchRequest: SaveSearchRequest, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveSearchApiV1SearchSavedSearchesPost(saveSearchRequest, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.saveSearchApiV1SearchSavedSearchesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search and replace across documents.  Returns:     Replacement results
         * @summary Search And Replace
         * @param {SearchReplaceRequest} searchReplaceRequest 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchAndReplaceApiV1SearchSearchReplacePost(searchReplaceRequest: SearchReplaceRequest, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchAndReplaceApiV1SearchSearchReplacePost(searchReplaceRequest, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchAndReplaceApiV1SearchSearchReplacePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Perform a search with various options.  Returns:     SearchResponse with results
         * @summary Search
         * @param {BackendAppApiRoutesSearchSearchRequest} backendAppApiRoutesSearchSearchRequest 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchApiV1SearchSearchPost(backendAppApiRoutesSearchSearchRequest: BackendAppApiRoutesSearchSearchRequest, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchApiV1SearchSearchPost(backendAppApiRoutesSearchSearchRequest, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchApiV1SearchSearchPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Perform semantic similarity search.  Returns:     SearchResponse with semantically similar results
         * @summary Semantic Search
         * @param {BackendAppApiRoutesSearchSearchRequest} backendAppApiRoutesSearchSearchRequest 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async semanticSearchApiV1SearchSearchSemanticPost(backendAppApiRoutesSearchSearchRequest: BackendAppApiRoutesSearchSearchRequest, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.semanticSearchApiV1SearchSearchSemanticPost(backendAppApiRoutesSearchSearchRequest, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.semanticSearchApiV1SearchSearchSemanticPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SearchApi - factory interface
 */
export const SearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SearchApiFp(configuration)
    return {
        /**
         * Perform boolean search with AND, OR, NOT operators.  Returns:     SearchResponse with boolean match results
         * @summary Boolean Search
         * @param {SearchApiBooleanSearchApiV1SearchSearchBooleanPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        booleanSearchApiV1SearchSearchBooleanPost(requestParameters: SearchApiBooleanSearchApiV1SearchSearchBooleanPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.booleanSearchApiV1SearchSearchBooleanPost(requestParameters.backendAppApiRoutesSearchSearchRequest, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a saved search.
         * @summary Delete Saved Search
         * @param {SearchApiDeleteSavedSearchApiV1SearchSavedSearchesSearchIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSavedSearchApiV1SearchSavedSearchesSearchIdDelete(requestParameters: SearchApiDeleteSavedSearchApiV1SearchSavedSearchesSearchIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.deleteSavedSearchApiV1SearchSavedSearchesSearchIdDelete(requestParameters.searchId, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Find documents similar to the given document.  Returns:     List of similar documents
         * @summary Find Similar Documents
         * @param {SearchApiFindSimilarDocumentsApiV1SearchDocumentsDocumentIdSimilarGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSimilarDocumentsApiV1SearchDocumentsDocumentIdSimilarGet(requestParameters: SearchApiFindSimilarDocumentsApiV1SearchDocumentsDocumentIdSimilarGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.findSimilarDocumentsApiV1SearchDocumentsDocumentIdSimilarGet(requestParameters.documentId, requestParameters.limit, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single saved search by ID.  Returns:     SavedSearch configuration
         * @summary Get Saved Search
         * @param {SearchApiGetSavedSearchApiV1SearchSavedSearchesSearchIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSavedSearchApiV1SearchSavedSearchesSearchIdGet(requestParameters: SearchApiGetSavedSearchApiV1SearchSavedSearchesSearchIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getSavedSearchApiV1SearchSavedSearchesSearchIdGet(requestParameters.searchId, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get search analytics.
         * @summary Get Search Analytics
         * @param {SearchApiGetSearchAnalyticsApiV1SearchAnalyticsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearchAnalyticsApiV1SearchAnalyticsGet(requestParameters: SearchApiGetSearchAnalyticsApiV1SearchAnalyticsGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getSearchAnalyticsApiV1SearchAnalyticsGet(requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get available search types.  Returns:     List of search types with descriptions
         * @summary Get Search Types
         * @param {SearchApiGetSearchTypesApiV1SearchTypesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearchTypesApiV1SearchTypesGet(requestParameters: SearchApiGetSearchTypesApiV1SearchTypesGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getSearchTypesApiV1SearchTypesGet(requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Index a document for searching.  Returns:     Success status
         * @summary Index Document
         * @param {SearchApiIndexDocumentApiV1SearchIndexPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexDocumentApiV1SearchIndexPost(requestParameters: SearchApiIndexDocumentApiV1SearchIndexPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.indexDocumentApiV1SearchIndexPost(requestParameters.indexDocumentRequest, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * List all saved searches.
         * @summary List Saved Searches
         * @param {SearchApiListSavedSearchesApiV1SearchSavedSearchesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSavedSearchesApiV1SearchSavedSearchesGet(requestParameters: SearchApiListSavedSearchesApiV1SearchSavedSearchesGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.listSavedSearchesApiV1SearchSavedSearchesGet(requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Perform regex pattern search.  Returns:     SearchResponse with regex matches  Raises:     HTTPException 400: If regex pattern is invalid or potentially dangerous
         * @summary Regex Search
         * @param {SearchApiRegexSearchApiV1SearchSearchRegexPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regexSearchApiV1SearchSearchRegexPost(requestParameters: SearchApiRegexSearchApiV1SearchSearchRegexPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.regexSearchApiV1SearchSearchRegexPost(requestParameters.backendAppApiRoutesSearchSearchRequest, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Reindex all documents in the search index.  Returns:     Reindex job status
         * @summary Reindex All
         * @param {SearchApiReindexAllApiV1SearchIndexReindexPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reindexAllApiV1SearchIndexReindexPost(requestParameters: SearchApiReindexAllApiV1SearchIndexReindexPostRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.reindexAllApiV1SearchIndexReindexPost(requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a document from the search index.  Returns:     Success status
         * @summary Remove From Index
         * @param {SearchApiRemoveFromIndexApiV1SearchIndexDocumentIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFromIndexApiV1SearchIndexDocumentIdDelete(requestParameters: SearchApiRemoveFromIndexApiV1SearchIndexDocumentIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.removeFromIndexApiV1SearchIndexDocumentIdDelete(requestParameters.documentId, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Run a saved search.
         * @summary Run Saved Search
         * @param {SearchApiRunSavedSearchApiV1SearchSavedSearchesSearchIdRunPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runSavedSearchApiV1SearchSavedSearchesSearchIdRunPost(requestParameters: SearchApiRunSavedSearchApiV1SearchSavedSearchesSearchIdRunPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.runSavedSearchApiV1SearchSavedSearchesSearchIdRunPost(requestParameters.searchId, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Save a search for later use.  Returns:     SavedSearch configuration
         * @summary Save Search
         * @param {SearchApiSaveSearchApiV1SearchSavedSearchesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveSearchApiV1SearchSavedSearchesPost(requestParameters: SearchApiSaveSearchApiV1SearchSavedSearchesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.saveSearchApiV1SearchSavedSearchesPost(requestParameters.saveSearchRequest, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Search and replace across documents.  Returns:     Replacement results
         * @summary Search And Replace
         * @param {SearchApiSearchAndReplaceApiV1SearchSearchReplacePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAndReplaceApiV1SearchSearchReplacePost(requestParameters: SearchApiSearchAndReplaceApiV1SearchSearchReplacePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.searchAndReplaceApiV1SearchSearchReplacePost(requestParameters.searchReplaceRequest, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Perform a search with various options.  Returns:     SearchResponse with results
         * @summary Search
         * @param {SearchApiSearchApiV1SearchSearchPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchApiV1SearchSearchPost(requestParameters: SearchApiSearchApiV1SearchSearchPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.searchApiV1SearchSearchPost(requestParameters.backendAppApiRoutesSearchSearchRequest, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Perform semantic similarity search.  Returns:     SearchResponse with semantically similar results
         * @summary Semantic Search
         * @param {SearchApiSemanticSearchApiV1SearchSearchSemanticPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        semanticSearchApiV1SearchSearchSemanticPost(requestParameters: SearchApiSemanticSearchApiV1SearchSearchSemanticPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.semanticSearchApiV1SearchSearchSemanticPost(requestParameters.backendAppApiRoutesSearchSearchRequest, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for booleanSearchApiV1SearchSearchBooleanPost operation in SearchApi.
 */
export interface SearchApiBooleanSearchApiV1SearchSearchBooleanPostRequest {
    readonly backendAppApiRoutesSearchSearchRequest: BackendAppApiRoutesSearchSearchRequest

    readonly xApiKey?: string | null
}

/**
 * Request parameters for deleteSavedSearchApiV1SearchSavedSearchesSearchIdDelete operation in SearchApi.
 */
export interface SearchApiDeleteSavedSearchApiV1SearchSavedSearchesSearchIdDeleteRequest {
    readonly searchId: string

    readonly xApiKey?: string | null
}

/**
 * Request parameters for findSimilarDocumentsApiV1SearchDocumentsDocumentIdSimilarGet operation in SearchApi.
 */
export interface SearchApiFindSimilarDocumentsApiV1SearchDocumentsDocumentIdSimilarGetRequest {
    readonly documentId: string

    readonly limit?: number

    readonly xApiKey?: string | null
}

/**
 * Request parameters for getSavedSearchApiV1SearchSavedSearchesSearchIdGet operation in SearchApi.
 */
export interface SearchApiGetSavedSearchApiV1SearchSavedSearchesSearchIdGetRequest {
    readonly searchId: string

    readonly xApiKey?: string | null
}

/**
 * Request parameters for getSearchAnalyticsApiV1SearchAnalyticsGet operation in SearchApi.
 */
export interface SearchApiGetSearchAnalyticsApiV1SearchAnalyticsGetRequest {
    readonly xApiKey?: string | null
}

/**
 * Request parameters for getSearchTypesApiV1SearchTypesGet operation in SearchApi.
 */
export interface SearchApiGetSearchTypesApiV1SearchTypesGetRequest {
    readonly xApiKey?: string | null
}

/**
 * Request parameters for indexDocumentApiV1SearchIndexPost operation in SearchApi.
 */
export interface SearchApiIndexDocumentApiV1SearchIndexPostRequest {
    readonly indexDocumentRequest: IndexDocumentRequest

    readonly xApiKey?: string | null
}

/**
 * Request parameters for listSavedSearchesApiV1SearchSavedSearchesGet operation in SearchApi.
 */
export interface SearchApiListSavedSearchesApiV1SearchSavedSearchesGetRequest {
    readonly xApiKey?: string | null
}

/**
 * Request parameters for regexSearchApiV1SearchSearchRegexPost operation in SearchApi.
 */
export interface SearchApiRegexSearchApiV1SearchSearchRegexPostRequest {
    readonly backendAppApiRoutesSearchSearchRequest: BackendAppApiRoutesSearchSearchRequest

    readonly xApiKey?: string | null
}

/**
 * Request parameters for reindexAllApiV1SearchIndexReindexPost operation in SearchApi.
 */
export interface SearchApiReindexAllApiV1SearchIndexReindexPostRequest {
    readonly xApiKey?: string | null
}

/**
 * Request parameters for removeFromIndexApiV1SearchIndexDocumentIdDelete operation in SearchApi.
 */
export interface SearchApiRemoveFromIndexApiV1SearchIndexDocumentIdDeleteRequest {
    readonly documentId: string

    readonly xApiKey?: string | null
}

/**
 * Request parameters for runSavedSearchApiV1SearchSavedSearchesSearchIdRunPost operation in SearchApi.
 */
export interface SearchApiRunSavedSearchApiV1SearchSavedSearchesSearchIdRunPostRequest {
    readonly searchId: string

    readonly xApiKey?: string | null
}

/**
 * Request parameters for saveSearchApiV1SearchSavedSearchesPost operation in SearchApi.
 */
export interface SearchApiSaveSearchApiV1SearchSavedSearchesPostRequest {
    readonly saveSearchRequest: SaveSearchRequest

    readonly xApiKey?: string | null
}

/**
 * Request parameters for searchAndReplaceApiV1SearchSearchReplacePost operation in SearchApi.
 */
export interface SearchApiSearchAndReplaceApiV1SearchSearchReplacePostRequest {
    readonly searchReplaceRequest: SearchReplaceRequest

    readonly xApiKey?: string | null
}

/**
 * Request parameters for searchApiV1SearchSearchPost operation in SearchApi.
 */
export interface SearchApiSearchApiV1SearchSearchPostRequest {
    readonly backendAppApiRoutesSearchSearchRequest: BackendAppApiRoutesSearchSearchRequest

    readonly xApiKey?: string | null
}

/**
 * Request parameters for semanticSearchApiV1SearchSearchSemanticPost operation in SearchApi.
 */
export interface SearchApiSemanticSearchApiV1SearchSearchSemanticPostRequest {
    readonly backendAppApiRoutesSearchSearchRequest: BackendAppApiRoutesSearchSearchRequest

    readonly xApiKey?: string | null
}

/**
 * SearchApi - object-oriented interface
 */
export class SearchApi extends BaseAPI {
    /**
     * Perform boolean search with AND, OR, NOT operators.  Returns:     SearchResponse with boolean match results
     * @summary Boolean Search
     * @param {SearchApiBooleanSearchApiV1SearchSearchBooleanPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public booleanSearchApiV1SearchSearchBooleanPost(requestParameters: SearchApiBooleanSearchApiV1SearchSearchBooleanPostRequest, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).booleanSearchApiV1SearchSearchBooleanPost(requestParameters.backendAppApiRoutesSearchSearchRequest, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a saved search.
     * @summary Delete Saved Search
     * @param {SearchApiDeleteSavedSearchApiV1SearchSavedSearchesSearchIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteSavedSearchApiV1SearchSavedSearchesSearchIdDelete(requestParameters: SearchApiDeleteSavedSearchApiV1SearchSavedSearchesSearchIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).deleteSavedSearchApiV1SearchSavedSearchesSearchIdDelete(requestParameters.searchId, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find documents similar to the given document.  Returns:     List of similar documents
     * @summary Find Similar Documents
     * @param {SearchApiFindSimilarDocumentsApiV1SearchDocumentsDocumentIdSimilarGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public findSimilarDocumentsApiV1SearchDocumentsDocumentIdSimilarGet(requestParameters: SearchApiFindSimilarDocumentsApiV1SearchDocumentsDocumentIdSimilarGetRequest, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).findSimilarDocumentsApiV1SearchDocumentsDocumentIdSimilarGet(requestParameters.documentId, requestParameters.limit, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single saved search by ID.  Returns:     SavedSearch configuration
     * @summary Get Saved Search
     * @param {SearchApiGetSavedSearchApiV1SearchSavedSearchesSearchIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSavedSearchApiV1SearchSavedSearchesSearchIdGet(requestParameters: SearchApiGetSavedSearchApiV1SearchSavedSearchesSearchIdGetRequest, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).getSavedSearchApiV1SearchSavedSearchesSearchIdGet(requestParameters.searchId, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get search analytics.
     * @summary Get Search Analytics
     * @param {SearchApiGetSearchAnalyticsApiV1SearchAnalyticsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSearchAnalyticsApiV1SearchAnalyticsGet(requestParameters: SearchApiGetSearchAnalyticsApiV1SearchAnalyticsGetRequest = {}, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).getSearchAnalyticsApiV1SearchAnalyticsGet(requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get available search types.  Returns:     List of search types with descriptions
     * @summary Get Search Types
     * @param {SearchApiGetSearchTypesApiV1SearchTypesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSearchTypesApiV1SearchTypesGet(requestParameters: SearchApiGetSearchTypesApiV1SearchTypesGetRequest = {}, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).getSearchTypesApiV1SearchTypesGet(requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Index a document for searching.  Returns:     Success status
     * @summary Index Document
     * @param {SearchApiIndexDocumentApiV1SearchIndexPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public indexDocumentApiV1SearchIndexPost(requestParameters: SearchApiIndexDocumentApiV1SearchIndexPostRequest, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).indexDocumentApiV1SearchIndexPost(requestParameters.indexDocumentRequest, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all saved searches.
     * @summary List Saved Searches
     * @param {SearchApiListSavedSearchesApiV1SearchSavedSearchesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listSavedSearchesApiV1SearchSavedSearchesGet(requestParameters: SearchApiListSavedSearchesApiV1SearchSavedSearchesGetRequest = {}, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).listSavedSearchesApiV1SearchSavedSearchesGet(requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Perform regex pattern search.  Returns:     SearchResponse with regex matches  Raises:     HTTPException 400: If regex pattern is invalid or potentially dangerous
     * @summary Regex Search
     * @param {SearchApiRegexSearchApiV1SearchSearchRegexPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public regexSearchApiV1SearchSearchRegexPost(requestParameters: SearchApiRegexSearchApiV1SearchSearchRegexPostRequest, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).regexSearchApiV1SearchSearchRegexPost(requestParameters.backendAppApiRoutesSearchSearchRequest, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reindex all documents in the search index.  Returns:     Reindex job status
     * @summary Reindex All
     * @param {SearchApiReindexAllApiV1SearchIndexReindexPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public reindexAllApiV1SearchIndexReindexPost(requestParameters: SearchApiReindexAllApiV1SearchIndexReindexPostRequest = {}, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).reindexAllApiV1SearchIndexReindexPost(requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a document from the search index.  Returns:     Success status
     * @summary Remove From Index
     * @param {SearchApiRemoveFromIndexApiV1SearchIndexDocumentIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public removeFromIndexApiV1SearchIndexDocumentIdDelete(requestParameters: SearchApiRemoveFromIndexApiV1SearchIndexDocumentIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).removeFromIndexApiV1SearchIndexDocumentIdDelete(requestParameters.documentId, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Run a saved search.
     * @summary Run Saved Search
     * @param {SearchApiRunSavedSearchApiV1SearchSavedSearchesSearchIdRunPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public runSavedSearchApiV1SearchSavedSearchesSearchIdRunPost(requestParameters: SearchApiRunSavedSearchApiV1SearchSavedSearchesSearchIdRunPostRequest, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).runSavedSearchApiV1SearchSavedSearchesSearchIdRunPost(requestParameters.searchId, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Save a search for later use.  Returns:     SavedSearch configuration
     * @summary Save Search
     * @param {SearchApiSaveSearchApiV1SearchSavedSearchesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public saveSearchApiV1SearchSavedSearchesPost(requestParameters: SearchApiSaveSearchApiV1SearchSavedSearchesPostRequest, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).saveSearchApiV1SearchSavedSearchesPost(requestParameters.saveSearchRequest, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search and replace across documents.  Returns:     Replacement results
     * @summary Search And Replace
     * @param {SearchApiSearchAndReplaceApiV1SearchSearchReplacePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public searchAndReplaceApiV1SearchSearchReplacePost(requestParameters: SearchApiSearchAndReplaceApiV1SearchSearchReplacePostRequest, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchAndReplaceApiV1SearchSearchReplacePost(requestParameters.searchReplaceRequest, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Perform a search with various options.  Returns:     SearchResponse with results
     * @summary Search
     * @param {SearchApiSearchApiV1SearchSearchPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public searchApiV1SearchSearchPost(requestParameters: SearchApiSearchApiV1SearchSearchPostRequest, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchApiV1SearchSearchPost(requestParameters.backendAppApiRoutesSearchSearchRequest, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Perform semantic similarity search.  Returns:     SearchResponse with semantically similar results
     * @summary Semantic Search
     * @param {SearchApiSemanticSearchApiV1SearchSearchSemanticPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public semanticSearchApiV1SearchSearchSemanticPost(requestParameters: SearchApiSemanticSearchApiV1SearchSearchSemanticPostRequest, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).semanticSearchApiV1SearchSearchSemanticPost(requestParameters.backendAppApiRoutesSearchSearchRequest, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }
}

