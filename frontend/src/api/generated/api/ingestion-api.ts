/* tslint:disable */
/* eslint-disable */
/**
 * NeuraReport API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 4.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, replaceWithSerializableTypeIfNeeded } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { ClipSelectionRequest } from '../models';
// @ts-ignore
import type { ClipUrlRequest } from '../models';
// @ts-ignore
import type { CreateWatcherRequest } from '../models';
// @ts-ignore
import type { GenerateInboxRequest } from '../models';
// @ts-ignore
import type { HTTPValidationError } from '../models';
// @ts-ignore
import type { ImapConnectRequest } from '../models';
// @ts-ignore
import type { IngestStructuredDataRequest } from '../models';
// @ts-ignore
import type { IngestUrlRequest } from '../models';
/**
 * IngestionApi - axios parameter creator
 */
export const IngestionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Clip a user-selected portion of a page.  Returns:     ClippedContent with selected content
         * @summary Clip Selection
         * @param {ClipSelectionRequest} clipSelectionRequest 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clipSelectionApiV1IngestionClipSelectionPost: async (clipSelectionRequest: ClipSelectionRequest, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clipSelectionRequest' is not null or undefined
            assertParamExists('clipSelectionApiV1IngestionClipSelectionPost', 'clipSelectionRequest', clipSelectionRequest)
            const localVarPath = `/api/v1/ingestion/clip/selection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clipSelectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Clip content from a web page.  Returns:     ClippedContent with extracted content
         * @summary Clip Web Page
         * @param {ClipUrlRequest} clipUrlRequest 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clipWebPageApiV1IngestionClipUrlPost: async (clipUrlRequest: ClipUrlRequest, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clipUrlRequest' is not null or undefined
            assertParamExists('clipWebPageApiV1IngestionClipUrlPost', 'clipUrlRequest', clipUrlRequest)
            const localVarPath = `/api/v1/ingestion/clip/url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clipUrlRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Connect an IMAP email account.  Tests the connection and stores the account configuration.  Returns:     Connection result with account ID
         * @summary Connect Imap Account
         * @param {ImapConnectRequest} imapConnectRequest 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectImapAccountApiV1IngestionEmailImapConnectPost: async (imapConnectRequest: ImapConnectRequest, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imapConnectRequest' is not null or undefined
            assertParamExists('connectImapAccountApiV1IngestionEmailImapConnectPost', 'imapConnectRequest', imapConnectRequest)
            const localVarPath = `/api/v1/ingestion/email/imap/connect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imapConnectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new folder watcher.  Returns:     WatcherStatus
         * @summary Create Folder Watcher
         * @param {CreateWatcherRequest} createWatcherRequest 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolderWatcherApiV1IngestionWatchersPost: async (createWatcherRequest: CreateWatcherRequest, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWatcherRequest' is not null or undefined
            assertParamExists('createFolderWatcherApiV1IngestionWatchersPost', 'createWatcherRequest', createWatcherRequest)
            const localVarPath = `/api/v1/ingestion/watchers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWatcherRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a folder watcher.
         * @summary Delete Watcher
         * @param {string} watcherId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWatcherApiV1IngestionWatchersWatcherIdDelete: async (watcherId: string, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'watcherId' is not null or undefined
            assertParamExists('deleteWatcherApiV1IngestionWatchersWatcherIdDelete', 'watcherId', watcherId)
            const localVarPath = `/api/v1/ingestion/watchers/{watcher_id}`
                .replace(`{${"watcher_id"}}`, encodeURIComponent(String(watcherId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Detect the type of an uploaded file.  Returns:     Detected file type and metadata
         * @summary Detect File Type
         * @param {File} file 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectFileTypeApiV1IngestionDetectTypePost: async (file: File, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('detectFileTypeApiV1IngestionDetectTypePost', 'file', file)
            const localVarPath = `/api/v1/ingestion/detect-type`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate a unique email inbox address for forwarding.  Returns:     Email address for forwarding
         * @summary Generate Inbox Address
         * @param {GenerateInboxRequest} generateInboxRequest 
         * @param {string} [userId] 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateInboxAddressApiV1IngestionEmailInboxPost: async (generateInboxRequest: GenerateInboxRequest, userId?: string, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'generateInboxRequest' is not null or undefined
            assertParamExists('generateInboxAddressApiV1IngestionEmailInboxPost', 'generateInboxRequest', generateInboxRequest)
            const localVarPath = `/api/v1/ingestion/email/inbox`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generateInboxRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the status of a transcription job.  Returns:     Job status, progress, and result when complete
         * @summary Get Transcription Status
         * @param {string} jobId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTranscriptionStatusApiV1IngestionTranscribeJobIdGet: async (jobId: string, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getTranscriptionStatusApiV1IngestionTranscribeJobIdGet', 'jobId', jobId)
            const localVarPath = `/api/v1/ingestion/transcribe/{job_id}`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get status of a folder watcher.  Returns:     WatcherStatus
         * @summary Get Watcher Status
         * @param {string} watcherId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWatcherStatusApiV1IngestionWatchersWatcherIdGet: async (watcherId: string, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'watcherId' is not null or undefined
            assertParamExists('getWatcherStatusApiV1IngestionWatchersWatcherIdGet', 'watcherId', watcherId)
            const localVarPath = `/api/v1/ingestion/watchers/{watcher_id}`
                .replace(`{${"watcher_id"}}`, encodeURIComponent(String(watcherId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Ingest a raw email file (.eml).  Returns:     EmailDocumentResult with created document
         * @summary Ingest Email
         * @param {File} file 
         * @param {string | null} [xApiKey] 
         * @param {boolean} [includeAttachments] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingestEmailApiV1IngestionEmailIngestPost: async (file: File, xApiKey?: string | null, includeAttachments?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('ingestEmailApiV1IngestionEmailIngestPost', 'file', file)
            const localVarPath = `/api/v1/ingestion/email/ingest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }

            if (includeAttachments !== undefined) { 
                localVarFormParams.append('include_attachments', String(includeAttachments) as any);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Download and ingest a file from a URL.  Returns:     IngestionResult with document details
         * @summary Ingest From Url
         * @param {IngestUrlRequest} ingestUrlRequest 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingestFromUrlApiV1IngestionUrlPost: async (ingestUrlRequest: IngestUrlRequest, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ingestUrlRequest' is not null or undefined
            assertParamExists('ingestFromUrlApiV1IngestionUrlPost', 'ingestUrlRequest', ingestUrlRequest)
            const localVarPath = `/api/v1/ingestion/url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ingestUrlRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import structured data (JSON/XML/YAML) as an editable table.  Returns:     StructuredDataImport with table details
         * @summary Ingest Structured Data
         * @param {IngestStructuredDataRequest} ingestStructuredDataRequest 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingestStructuredDataApiV1IngestionStructuredPost: async (ingestStructuredDataRequest: IngestStructuredDataRequest, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ingestStructuredDataRequest' is not null or undefined
            assertParamExists('ingestStructuredDataApiV1IngestionStructuredPost', 'ingestStructuredDataRequest', ingestStructuredDataRequest)
            const localVarPath = `/api/v1/ingestion/structured`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ingestStructuredDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all folder watchers.  Returns:     List of WatcherStatus
         * @summary List Folder Watchers
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFolderWatchersApiV1IngestionWatchersGet: async (xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/ingestion/watchers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List connected IMAP email accounts.  Returns:     List of connected IMAP accounts
         * @summary List Imap Accounts
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listImapAccountsApiV1IngestionEmailImapAccountsGet: async (xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/ingestion/email/imap/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all supported file types for ingestion.  Returns:     List of supported file types
         * @summary List Supported Types
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupportedTypesApiV1IngestionSupportedTypesGet: async (xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/ingestion/supported-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Parse an email and extract structured data.  Returns:     Parsed email with action items and links
         * @summary Parse Email
         * @param {File} file 
         * @param {string | null} [xApiKey] 
         * @param {boolean} [extractActionItems] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parseEmailApiV1IngestionEmailParsePost: async (file: File, xApiKey?: string | null, extractActionItems?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('parseEmailApiV1IngestionEmailParsePost', 'file', file)
            const localVarPath = `/api/v1/ingestion/email/parse`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


            if (extractActionItems !== undefined) { 
                localVarFormParams.append('extract_action_items', String(extractActionItems) as any);
            }

            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Manually scan a watched folder for existing files.  Returns:     List of FileEvents
         * @summary Scan Watched Folder
         * @param {string} watcherId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scanWatchedFolderApiV1IngestionWatchersWatcherIdScanPost: async (watcherId: string, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'watcherId' is not null or undefined
            assertParamExists('scanWatchedFolderApiV1IngestionWatchersWatcherIdScanPost', 'watcherId', watcherId)
            const localVarPath = `/api/v1/ingestion/watchers/{watcher_id}/scan`
                .replace(`{${"watcher_id"}}`, encodeURIComponent(String(watcherId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a folder watcher.
         * @summary Start Watcher
         * @param {string} watcherId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startWatcherApiV1IngestionWatchersWatcherIdStartPost: async (watcherId: string, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'watcherId' is not null or undefined
            assertParamExists('startWatcherApiV1IngestionWatchersWatcherIdStartPost', 'watcherId', watcherId)
            const localVarPath = `/api/v1/ingestion/watchers/{watcher_id}/start`
                .replace(`{${"watcher_id"}}`, encodeURIComponent(String(watcherId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stop a folder watcher.
         * @summary Stop Watcher
         * @param {string} watcherId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopWatcherApiV1IngestionWatchersWatcherIdStopPost: async (watcherId: string, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'watcherId' is not null or undefined
            assertParamExists('stopWatcherApiV1IngestionWatchersWatcherIdStopPost', 'watcherId', watcherId)
            const localVarPath = `/api/v1/ingestion/watchers/{watcher_id}/stop`
                .replace(`{${"watcher_id"}}`, encodeURIComponent(String(watcherId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sync emails from an IMAP account.  Triggers email synchronisation for the specified account.  Returns:     Sync job status
         * @summary Sync Imap Account
         * @param {string} accountId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncImapAccountApiV1IngestionEmailImapAccountsAccountIdSyncPost: async (accountId: string, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('syncImapAccountApiV1IngestionEmailImapAccountsAccountIdSyncPost', 'accountId', accountId)
            const localVarPath = `/api/v1/ingestion/email/imap/accounts/{account_id}/sync`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Transcribe an audio or video file.  Returns:     TranscriptionResult with full transcript
         * @summary Transcribe File
         * @param {File} file 
         * @param {string | null} [xApiKey] 
         * @param {boolean} [diarizeSpeakers] 
         * @param {boolean} [includeTimestamps] 
         * @param {string} [language] 
         * @param {string} [outputFormat] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transcribeFileApiV1IngestionTranscribePost: async (file: File, xApiKey?: string | null, diarizeSpeakers?: boolean, includeTimestamps?: boolean, language?: string, outputFormat?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('transcribeFileApiV1IngestionTranscribePost', 'file', file)
            const localVarPath = `/api/v1/ingestion/transcribe`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


            if (diarizeSpeakers !== undefined) { 
                localVarFormParams.append('diarize_speakers', String(diarizeSpeakers) as any);
            }

            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }

            if (includeTimestamps !== undefined) { 
                localVarFormParams.append('include_timestamps', String(includeTimestamps) as any);
            }

            if (language !== undefined) { 
                localVarFormParams.append('language', language as any);
            }

            if (outputFormat !== undefined) { 
                localVarFormParams.append('output_format', outputFormat as any);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Transcribe a voice memo with intelligent extraction.  Returns:     VoiceMemoResult with transcript and extracted items
         * @summary Transcribe Voice Memo
         * @param {File} file 
         * @param {string | null} [xApiKey] 
         * @param {boolean} [extractActionItems] 
         * @param {boolean} [extractKeyPoints] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transcribeVoiceMemoApiV1IngestionTranscribeVoiceMemoPost: async (file: File, xApiKey?: string | null, extractActionItems?: boolean, extractKeyPoints?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('transcribeVoiceMemoApiV1IngestionTranscribeVoiceMemoPost', 'file', file)
            const localVarPath = `/api/v1/ingestion/transcribe/voice-memo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


            if (extractActionItems !== undefined) { 
                localVarFormParams.append('extract_action_items', String(extractActionItems) as any);
            }

            if (extractKeyPoints !== undefined) { 
                localVarFormParams.append('extract_key_points', String(extractKeyPoints) as any);
            }

            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload multiple files at once.  Returns:     List of IngestionResults
         * @summary Upload Bulk
         * @param {Array<File>} files 
         * @param {string | null} [xApiKey] 
         * @param {string} [collection] 
         * @param {string} [tags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadBulkApiV1IngestionUploadBulkPost: async (files: Array<File>, xApiKey?: string | null, collection?: string, tags?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'files' is not null or undefined
            assertParamExists('uploadBulkApiV1IngestionUploadBulkPost', 'files', files)
            const localVarPath = `/api/v1/ingestion/upload/bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


            if (collection !== undefined) { 
                localVarFormParams.append('collection', collection as any);
            }
            if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }


            if (tags !== undefined) { 
                localVarFormParams.append('tags', tags as any);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload and ingest a file with auto-detection.  Returns:     IngestionResult with document details
         * @summary Upload File
         * @param {File} file 
         * @param {string | null} [xApiKey] 
         * @param {boolean} [autoOcr] 
         * @param {string} [collection] 
         * @param {boolean} [generatePreview] 
         * @param {string} [tags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileApiV1IngestionUploadPost: async (file: File, xApiKey?: string | null, autoOcr?: boolean, collection?: string, generatePreview?: boolean, tags?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadFileApiV1IngestionUploadPost', 'file', file)
            const localVarPath = `/api/v1/ingestion/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


            if (autoOcr !== undefined) { 
                localVarFormParams.append('auto_ocr', String(autoOcr) as any);
            }

            if (collection !== undefined) { 
                localVarFormParams.append('collection', collection as any);
            }

            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }

            if (generatePreview !== undefined) { 
                localVarFormParams.append('generate_preview', String(generatePreview) as any);
            }

            if (tags !== undefined) { 
                localVarFormParams.append('tags', tags as any);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload and extract a ZIP archive.  Returns:     BulkIngestionResult with all extracted documents
         * @summary Upload Zip
         * @param {File} file 
         * @param {string | null} [xApiKey] 
         * @param {boolean} [flatten] 
         * @param {boolean} [preserveStructure] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadZipApiV1IngestionUploadZipPost: async (file: File, xApiKey?: string | null, flatten?: boolean, preserveStructure?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadZipApiV1IngestionUploadZipPost', 'file', file)
            const localVarPath = `/api/v1/ingestion/upload/zip`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }

            if (flatten !== undefined) { 
                localVarFormParams.append('flatten', String(flatten) as any);
            }

            if (preserveStructure !== undefined) { 
                localVarFormParams.append('preserve_structure', String(preserveStructure) as any);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IngestionApi - functional programming interface
 */
export const IngestionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IngestionApiAxiosParamCreator(configuration)
    return {
        /**
         * Clip a user-selected portion of a page.  Returns:     ClippedContent with selected content
         * @summary Clip Selection
         * @param {ClipSelectionRequest} clipSelectionRequest 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clipSelectionApiV1IngestionClipSelectionPost(clipSelectionRequest: ClipSelectionRequest, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clipSelectionApiV1IngestionClipSelectionPost(clipSelectionRequest, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IngestionApi.clipSelectionApiV1IngestionClipSelectionPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Clip content from a web page.  Returns:     ClippedContent with extracted content
         * @summary Clip Web Page
         * @param {ClipUrlRequest} clipUrlRequest 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clipWebPageApiV1IngestionClipUrlPost(clipUrlRequest: ClipUrlRequest, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clipWebPageApiV1IngestionClipUrlPost(clipUrlRequest, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IngestionApi.clipWebPageApiV1IngestionClipUrlPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Connect an IMAP email account.  Tests the connection and stores the account configuration.  Returns:     Connection result with account ID
         * @summary Connect Imap Account
         * @param {ImapConnectRequest} imapConnectRequest 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectImapAccountApiV1IngestionEmailImapConnectPost(imapConnectRequest: ImapConnectRequest, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectImapAccountApiV1IngestionEmailImapConnectPost(imapConnectRequest, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IngestionApi.connectImapAccountApiV1IngestionEmailImapConnectPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new folder watcher.  Returns:     WatcherStatus
         * @summary Create Folder Watcher
         * @param {CreateWatcherRequest} createWatcherRequest 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFolderWatcherApiV1IngestionWatchersPost(createWatcherRequest: CreateWatcherRequest, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFolderWatcherApiV1IngestionWatchersPost(createWatcherRequest, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IngestionApi.createFolderWatcherApiV1IngestionWatchersPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a folder watcher.
         * @summary Delete Watcher
         * @param {string} watcherId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWatcherApiV1IngestionWatchersWatcherIdDelete(watcherId: string, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWatcherApiV1IngestionWatchersWatcherIdDelete(watcherId, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IngestionApi.deleteWatcherApiV1IngestionWatchersWatcherIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Detect the type of an uploaded file.  Returns:     Detected file type and metadata
         * @summary Detect File Type
         * @param {File} file 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detectFileTypeApiV1IngestionDetectTypePost(file: File, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detectFileTypeApiV1IngestionDetectTypePost(file, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IngestionApi.detectFileTypeApiV1IngestionDetectTypePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generate a unique email inbox address for forwarding.  Returns:     Email address for forwarding
         * @summary Generate Inbox Address
         * @param {GenerateInboxRequest} generateInboxRequest 
         * @param {string} [userId] 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateInboxAddressApiV1IngestionEmailInboxPost(generateInboxRequest: GenerateInboxRequest, userId?: string, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateInboxAddressApiV1IngestionEmailInboxPost(generateInboxRequest, userId, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IngestionApi.generateInboxAddressApiV1IngestionEmailInboxPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the status of a transcription job.  Returns:     Job status, progress, and result when complete
         * @summary Get Transcription Status
         * @param {string} jobId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTranscriptionStatusApiV1IngestionTranscribeJobIdGet(jobId: string, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTranscriptionStatusApiV1IngestionTranscribeJobIdGet(jobId, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IngestionApi.getTranscriptionStatusApiV1IngestionTranscribeJobIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get status of a folder watcher.  Returns:     WatcherStatus
         * @summary Get Watcher Status
         * @param {string} watcherId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWatcherStatusApiV1IngestionWatchersWatcherIdGet(watcherId: string, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWatcherStatusApiV1IngestionWatchersWatcherIdGet(watcherId, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IngestionApi.getWatcherStatusApiV1IngestionWatchersWatcherIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Ingest a raw email file (.eml).  Returns:     EmailDocumentResult with created document
         * @summary Ingest Email
         * @param {File} file 
         * @param {string | null} [xApiKey] 
         * @param {boolean} [includeAttachments] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ingestEmailApiV1IngestionEmailIngestPost(file: File, xApiKey?: string | null, includeAttachments?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ingestEmailApiV1IngestionEmailIngestPost(file, xApiKey, includeAttachments, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IngestionApi.ingestEmailApiV1IngestionEmailIngestPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Download and ingest a file from a URL.  Returns:     IngestionResult with document details
         * @summary Ingest From Url
         * @param {IngestUrlRequest} ingestUrlRequest 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ingestFromUrlApiV1IngestionUrlPost(ingestUrlRequest: IngestUrlRequest, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ingestFromUrlApiV1IngestionUrlPost(ingestUrlRequest, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IngestionApi.ingestFromUrlApiV1IngestionUrlPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Import structured data (JSON/XML/YAML) as an editable table.  Returns:     StructuredDataImport with table details
         * @summary Ingest Structured Data
         * @param {IngestStructuredDataRequest} ingestStructuredDataRequest 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ingestStructuredDataApiV1IngestionStructuredPost(ingestStructuredDataRequest: IngestStructuredDataRequest, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ingestStructuredDataApiV1IngestionStructuredPost(ingestStructuredDataRequest, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IngestionApi.ingestStructuredDataApiV1IngestionStructuredPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all folder watchers.  Returns:     List of WatcherStatus
         * @summary List Folder Watchers
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFolderWatchersApiV1IngestionWatchersGet(xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFolderWatchersApiV1IngestionWatchersGet(xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IngestionApi.listFolderWatchersApiV1IngestionWatchersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List connected IMAP email accounts.  Returns:     List of connected IMAP accounts
         * @summary List Imap Accounts
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listImapAccountsApiV1IngestionEmailImapAccountsGet(xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listImapAccountsApiV1IngestionEmailImapAccountsGet(xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IngestionApi.listImapAccountsApiV1IngestionEmailImapAccountsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all supported file types for ingestion.  Returns:     List of supported file types
         * @summary List Supported Types
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSupportedTypesApiV1IngestionSupportedTypesGet(xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSupportedTypesApiV1IngestionSupportedTypesGet(xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IngestionApi.listSupportedTypesApiV1IngestionSupportedTypesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Parse an email and extract structured data.  Returns:     Parsed email with action items and links
         * @summary Parse Email
         * @param {File} file 
         * @param {string | null} [xApiKey] 
         * @param {boolean} [extractActionItems] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parseEmailApiV1IngestionEmailParsePost(file: File, xApiKey?: string | null, extractActionItems?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.parseEmailApiV1IngestionEmailParsePost(file, xApiKey, extractActionItems, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IngestionApi.parseEmailApiV1IngestionEmailParsePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Manually scan a watched folder for existing files.  Returns:     List of FileEvents
         * @summary Scan Watched Folder
         * @param {string} watcherId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scanWatchedFolderApiV1IngestionWatchersWatcherIdScanPost(watcherId: string, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scanWatchedFolderApiV1IngestionWatchersWatcherIdScanPost(watcherId, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IngestionApi.scanWatchedFolderApiV1IngestionWatchersWatcherIdScanPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Start a folder watcher.
         * @summary Start Watcher
         * @param {string} watcherId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startWatcherApiV1IngestionWatchersWatcherIdStartPost(watcherId: string, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startWatcherApiV1IngestionWatchersWatcherIdStartPost(watcherId, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IngestionApi.startWatcherApiV1IngestionWatchersWatcherIdStartPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Stop a folder watcher.
         * @summary Stop Watcher
         * @param {string} watcherId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopWatcherApiV1IngestionWatchersWatcherIdStopPost(watcherId: string, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopWatcherApiV1IngestionWatchersWatcherIdStopPost(watcherId, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IngestionApi.stopWatcherApiV1IngestionWatchersWatcherIdStopPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sync emails from an IMAP account.  Triggers email synchronisation for the specified account.  Returns:     Sync job status
         * @summary Sync Imap Account
         * @param {string} accountId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncImapAccountApiV1IngestionEmailImapAccountsAccountIdSyncPost(accountId: string, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncImapAccountApiV1IngestionEmailImapAccountsAccountIdSyncPost(accountId, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IngestionApi.syncImapAccountApiV1IngestionEmailImapAccountsAccountIdSyncPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Transcribe an audio or video file.  Returns:     TranscriptionResult with full transcript
         * @summary Transcribe File
         * @param {File} file 
         * @param {string | null} [xApiKey] 
         * @param {boolean} [diarizeSpeakers] 
         * @param {boolean} [includeTimestamps] 
         * @param {string} [language] 
         * @param {string} [outputFormat] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transcribeFileApiV1IngestionTranscribePost(file: File, xApiKey?: string | null, diarizeSpeakers?: boolean, includeTimestamps?: boolean, language?: string, outputFormat?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transcribeFileApiV1IngestionTranscribePost(file, xApiKey, diarizeSpeakers, includeTimestamps, language, outputFormat, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IngestionApi.transcribeFileApiV1IngestionTranscribePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Transcribe a voice memo with intelligent extraction.  Returns:     VoiceMemoResult with transcript and extracted items
         * @summary Transcribe Voice Memo
         * @param {File} file 
         * @param {string | null} [xApiKey] 
         * @param {boolean} [extractActionItems] 
         * @param {boolean} [extractKeyPoints] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transcribeVoiceMemoApiV1IngestionTranscribeVoiceMemoPost(file: File, xApiKey?: string | null, extractActionItems?: boolean, extractKeyPoints?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transcribeVoiceMemoApiV1IngestionTranscribeVoiceMemoPost(file, xApiKey, extractActionItems, extractKeyPoints, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IngestionApi.transcribeVoiceMemoApiV1IngestionTranscribeVoiceMemoPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload multiple files at once.  Returns:     List of IngestionResults
         * @summary Upload Bulk
         * @param {Array<File>} files 
         * @param {string | null} [xApiKey] 
         * @param {string} [collection] 
         * @param {string} [tags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadBulkApiV1IngestionUploadBulkPost(files: Array<File>, xApiKey?: string | null, collection?: string, tags?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadBulkApiV1IngestionUploadBulkPost(files, xApiKey, collection, tags, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IngestionApi.uploadBulkApiV1IngestionUploadBulkPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload and ingest a file with auto-detection.  Returns:     IngestionResult with document details
         * @summary Upload File
         * @param {File} file 
         * @param {string | null} [xApiKey] 
         * @param {boolean} [autoOcr] 
         * @param {string} [collection] 
         * @param {boolean} [generatePreview] 
         * @param {string} [tags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFileApiV1IngestionUploadPost(file: File, xApiKey?: string | null, autoOcr?: boolean, collection?: string, generatePreview?: boolean, tags?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFileApiV1IngestionUploadPost(file, xApiKey, autoOcr, collection, generatePreview, tags, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IngestionApi.uploadFileApiV1IngestionUploadPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload and extract a ZIP archive.  Returns:     BulkIngestionResult with all extracted documents
         * @summary Upload Zip
         * @param {File} file 
         * @param {string | null} [xApiKey] 
         * @param {boolean} [flatten] 
         * @param {boolean} [preserveStructure] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadZipApiV1IngestionUploadZipPost(file: File, xApiKey?: string | null, flatten?: boolean, preserveStructure?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadZipApiV1IngestionUploadZipPost(file, xApiKey, flatten, preserveStructure, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IngestionApi.uploadZipApiV1IngestionUploadZipPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IngestionApi - factory interface
 */
export const IngestionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IngestionApiFp(configuration)
    return {
        /**
         * Clip a user-selected portion of a page.  Returns:     ClippedContent with selected content
         * @summary Clip Selection
         * @param {IngestionApiClipSelectionApiV1IngestionClipSelectionPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clipSelectionApiV1IngestionClipSelectionPost(requestParameters: IngestionApiClipSelectionApiV1IngestionClipSelectionPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.clipSelectionApiV1IngestionClipSelectionPost(requestParameters.clipSelectionRequest, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Clip content from a web page.  Returns:     ClippedContent with extracted content
         * @summary Clip Web Page
         * @param {IngestionApiClipWebPageApiV1IngestionClipUrlPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clipWebPageApiV1IngestionClipUrlPost(requestParameters: IngestionApiClipWebPageApiV1IngestionClipUrlPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.clipWebPageApiV1IngestionClipUrlPost(requestParameters.clipUrlRequest, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Connect an IMAP email account.  Tests the connection and stores the account configuration.  Returns:     Connection result with account ID
         * @summary Connect Imap Account
         * @param {IngestionApiConnectImapAccountApiV1IngestionEmailImapConnectPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectImapAccountApiV1IngestionEmailImapConnectPost(requestParameters: IngestionApiConnectImapAccountApiV1IngestionEmailImapConnectPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.connectImapAccountApiV1IngestionEmailImapConnectPost(requestParameters.imapConnectRequest, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new folder watcher.  Returns:     WatcherStatus
         * @summary Create Folder Watcher
         * @param {IngestionApiCreateFolderWatcherApiV1IngestionWatchersPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolderWatcherApiV1IngestionWatchersPost(requestParameters: IngestionApiCreateFolderWatcherApiV1IngestionWatchersPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.createFolderWatcherApiV1IngestionWatchersPost(requestParameters.createWatcherRequest, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a folder watcher.
         * @summary Delete Watcher
         * @param {IngestionApiDeleteWatcherApiV1IngestionWatchersWatcherIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWatcherApiV1IngestionWatchersWatcherIdDelete(requestParameters: IngestionApiDeleteWatcherApiV1IngestionWatchersWatcherIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.deleteWatcherApiV1IngestionWatchersWatcherIdDelete(requestParameters.watcherId, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Detect the type of an uploaded file.  Returns:     Detected file type and metadata
         * @summary Detect File Type
         * @param {IngestionApiDetectFileTypeApiV1IngestionDetectTypePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectFileTypeApiV1IngestionDetectTypePost(requestParameters: IngestionApiDetectFileTypeApiV1IngestionDetectTypePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.detectFileTypeApiV1IngestionDetectTypePost(requestParameters.file, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate a unique email inbox address for forwarding.  Returns:     Email address for forwarding
         * @summary Generate Inbox Address
         * @param {IngestionApiGenerateInboxAddressApiV1IngestionEmailInboxPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateInboxAddressApiV1IngestionEmailInboxPost(requestParameters: IngestionApiGenerateInboxAddressApiV1IngestionEmailInboxPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.generateInboxAddressApiV1IngestionEmailInboxPost(requestParameters.generateInboxRequest, requestParameters.userId, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the status of a transcription job.  Returns:     Job status, progress, and result when complete
         * @summary Get Transcription Status
         * @param {IngestionApiGetTranscriptionStatusApiV1IngestionTranscribeJobIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTranscriptionStatusApiV1IngestionTranscribeJobIdGet(requestParameters: IngestionApiGetTranscriptionStatusApiV1IngestionTranscribeJobIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getTranscriptionStatusApiV1IngestionTranscribeJobIdGet(requestParameters.jobId, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get status of a folder watcher.  Returns:     WatcherStatus
         * @summary Get Watcher Status
         * @param {IngestionApiGetWatcherStatusApiV1IngestionWatchersWatcherIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWatcherStatusApiV1IngestionWatchersWatcherIdGet(requestParameters: IngestionApiGetWatcherStatusApiV1IngestionWatchersWatcherIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getWatcherStatusApiV1IngestionWatchersWatcherIdGet(requestParameters.watcherId, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Ingest a raw email file (.eml).  Returns:     EmailDocumentResult with created document
         * @summary Ingest Email
         * @param {IngestionApiIngestEmailApiV1IngestionEmailIngestPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingestEmailApiV1IngestionEmailIngestPost(requestParameters: IngestionApiIngestEmailApiV1IngestionEmailIngestPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.ingestEmailApiV1IngestionEmailIngestPost(requestParameters.file, requestParameters.xApiKey, requestParameters.includeAttachments, options).then((request) => request(axios, basePath));
        },
        /**
         * Download and ingest a file from a URL.  Returns:     IngestionResult with document details
         * @summary Ingest From Url
         * @param {IngestionApiIngestFromUrlApiV1IngestionUrlPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingestFromUrlApiV1IngestionUrlPost(requestParameters: IngestionApiIngestFromUrlApiV1IngestionUrlPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.ingestFromUrlApiV1IngestionUrlPost(requestParameters.ingestUrlRequest, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Import structured data (JSON/XML/YAML) as an editable table.  Returns:     StructuredDataImport with table details
         * @summary Ingest Structured Data
         * @param {IngestionApiIngestStructuredDataApiV1IngestionStructuredPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingestStructuredDataApiV1IngestionStructuredPost(requestParameters: IngestionApiIngestStructuredDataApiV1IngestionStructuredPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.ingestStructuredDataApiV1IngestionStructuredPost(requestParameters.ingestStructuredDataRequest, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * List all folder watchers.  Returns:     List of WatcherStatus
         * @summary List Folder Watchers
         * @param {IngestionApiListFolderWatchersApiV1IngestionWatchersGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFolderWatchersApiV1IngestionWatchersGet(requestParameters: IngestionApiListFolderWatchersApiV1IngestionWatchersGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.listFolderWatchersApiV1IngestionWatchersGet(requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * List connected IMAP email accounts.  Returns:     List of connected IMAP accounts
         * @summary List Imap Accounts
         * @param {IngestionApiListImapAccountsApiV1IngestionEmailImapAccountsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listImapAccountsApiV1IngestionEmailImapAccountsGet(requestParameters: IngestionApiListImapAccountsApiV1IngestionEmailImapAccountsGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.listImapAccountsApiV1IngestionEmailImapAccountsGet(requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * List all supported file types for ingestion.  Returns:     List of supported file types
         * @summary List Supported Types
         * @param {IngestionApiListSupportedTypesApiV1IngestionSupportedTypesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupportedTypesApiV1IngestionSupportedTypesGet(requestParameters: IngestionApiListSupportedTypesApiV1IngestionSupportedTypesGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.listSupportedTypesApiV1IngestionSupportedTypesGet(requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Parse an email and extract structured data.  Returns:     Parsed email with action items and links
         * @summary Parse Email
         * @param {IngestionApiParseEmailApiV1IngestionEmailParsePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parseEmailApiV1IngestionEmailParsePost(requestParameters: IngestionApiParseEmailApiV1IngestionEmailParsePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.parseEmailApiV1IngestionEmailParsePost(requestParameters.file, requestParameters.xApiKey, requestParameters.extractActionItems, options).then((request) => request(axios, basePath));
        },
        /**
         * Manually scan a watched folder for existing files.  Returns:     List of FileEvents
         * @summary Scan Watched Folder
         * @param {IngestionApiScanWatchedFolderApiV1IngestionWatchersWatcherIdScanPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scanWatchedFolderApiV1IngestionWatchersWatcherIdScanPost(requestParameters: IngestionApiScanWatchedFolderApiV1IngestionWatchersWatcherIdScanPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.scanWatchedFolderApiV1IngestionWatchersWatcherIdScanPost(requestParameters.watcherId, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Start a folder watcher.
         * @summary Start Watcher
         * @param {IngestionApiStartWatcherApiV1IngestionWatchersWatcherIdStartPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startWatcherApiV1IngestionWatchersWatcherIdStartPost(requestParameters: IngestionApiStartWatcherApiV1IngestionWatchersWatcherIdStartPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.startWatcherApiV1IngestionWatchersWatcherIdStartPost(requestParameters.watcherId, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Stop a folder watcher.
         * @summary Stop Watcher
         * @param {IngestionApiStopWatcherApiV1IngestionWatchersWatcherIdStopPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopWatcherApiV1IngestionWatchersWatcherIdStopPost(requestParameters: IngestionApiStopWatcherApiV1IngestionWatchersWatcherIdStopPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.stopWatcherApiV1IngestionWatchersWatcherIdStopPost(requestParameters.watcherId, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Sync emails from an IMAP account.  Triggers email synchronisation for the specified account.  Returns:     Sync job status
         * @summary Sync Imap Account
         * @param {IngestionApiSyncImapAccountApiV1IngestionEmailImapAccountsAccountIdSyncPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncImapAccountApiV1IngestionEmailImapAccountsAccountIdSyncPost(requestParameters: IngestionApiSyncImapAccountApiV1IngestionEmailImapAccountsAccountIdSyncPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.syncImapAccountApiV1IngestionEmailImapAccountsAccountIdSyncPost(requestParameters.accountId, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Transcribe an audio or video file.  Returns:     TranscriptionResult with full transcript
         * @summary Transcribe File
         * @param {IngestionApiTranscribeFileApiV1IngestionTranscribePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transcribeFileApiV1IngestionTranscribePost(requestParameters: IngestionApiTranscribeFileApiV1IngestionTranscribePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.transcribeFileApiV1IngestionTranscribePost(requestParameters.file, requestParameters.xApiKey, requestParameters.diarizeSpeakers, requestParameters.includeTimestamps, requestParameters.language, requestParameters.outputFormat, options).then((request) => request(axios, basePath));
        },
        /**
         * Transcribe a voice memo with intelligent extraction.  Returns:     VoiceMemoResult with transcript and extracted items
         * @summary Transcribe Voice Memo
         * @param {IngestionApiTranscribeVoiceMemoApiV1IngestionTranscribeVoiceMemoPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transcribeVoiceMemoApiV1IngestionTranscribeVoiceMemoPost(requestParameters: IngestionApiTranscribeVoiceMemoApiV1IngestionTranscribeVoiceMemoPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.transcribeVoiceMemoApiV1IngestionTranscribeVoiceMemoPost(requestParameters.file, requestParameters.xApiKey, requestParameters.extractActionItems, requestParameters.extractKeyPoints, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload multiple files at once.  Returns:     List of IngestionResults
         * @summary Upload Bulk
         * @param {IngestionApiUploadBulkApiV1IngestionUploadBulkPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadBulkApiV1IngestionUploadBulkPost(requestParameters: IngestionApiUploadBulkApiV1IngestionUploadBulkPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.uploadBulkApiV1IngestionUploadBulkPost(requestParameters.files, requestParameters.xApiKey, requestParameters.collection, requestParameters.tags, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload and ingest a file with auto-detection.  Returns:     IngestionResult with document details
         * @summary Upload File
         * @param {IngestionApiUploadFileApiV1IngestionUploadPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileApiV1IngestionUploadPost(requestParameters: IngestionApiUploadFileApiV1IngestionUploadPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.uploadFileApiV1IngestionUploadPost(requestParameters.file, requestParameters.xApiKey, requestParameters.autoOcr, requestParameters.collection, requestParameters.generatePreview, requestParameters.tags, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload and extract a ZIP archive.  Returns:     BulkIngestionResult with all extracted documents
         * @summary Upload Zip
         * @param {IngestionApiUploadZipApiV1IngestionUploadZipPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadZipApiV1IngestionUploadZipPost(requestParameters: IngestionApiUploadZipApiV1IngestionUploadZipPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.uploadZipApiV1IngestionUploadZipPost(requestParameters.file, requestParameters.xApiKey, requestParameters.flatten, requestParameters.preserveStructure, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for clipSelectionApiV1IngestionClipSelectionPost operation in IngestionApi.
 */
export interface IngestionApiClipSelectionApiV1IngestionClipSelectionPostRequest {
    readonly clipSelectionRequest: ClipSelectionRequest

    readonly xApiKey?: string | null
}

/**
 * Request parameters for clipWebPageApiV1IngestionClipUrlPost operation in IngestionApi.
 */
export interface IngestionApiClipWebPageApiV1IngestionClipUrlPostRequest {
    readonly clipUrlRequest: ClipUrlRequest

    readonly xApiKey?: string | null
}

/**
 * Request parameters for connectImapAccountApiV1IngestionEmailImapConnectPost operation in IngestionApi.
 */
export interface IngestionApiConnectImapAccountApiV1IngestionEmailImapConnectPostRequest {
    readonly imapConnectRequest: ImapConnectRequest

    readonly xApiKey?: string | null
}

/**
 * Request parameters for createFolderWatcherApiV1IngestionWatchersPost operation in IngestionApi.
 */
export interface IngestionApiCreateFolderWatcherApiV1IngestionWatchersPostRequest {
    readonly createWatcherRequest: CreateWatcherRequest

    readonly xApiKey?: string | null
}

/**
 * Request parameters for deleteWatcherApiV1IngestionWatchersWatcherIdDelete operation in IngestionApi.
 */
export interface IngestionApiDeleteWatcherApiV1IngestionWatchersWatcherIdDeleteRequest {
    readonly watcherId: string

    readonly xApiKey?: string | null
}

/**
 * Request parameters for detectFileTypeApiV1IngestionDetectTypePost operation in IngestionApi.
 */
export interface IngestionApiDetectFileTypeApiV1IngestionDetectTypePostRequest {
    readonly file: File

    readonly xApiKey?: string | null
}

/**
 * Request parameters for generateInboxAddressApiV1IngestionEmailInboxPost operation in IngestionApi.
 */
export interface IngestionApiGenerateInboxAddressApiV1IngestionEmailInboxPostRequest {
    readonly generateInboxRequest: GenerateInboxRequest

    readonly userId?: string

    readonly xApiKey?: string | null
}

/**
 * Request parameters for getTranscriptionStatusApiV1IngestionTranscribeJobIdGet operation in IngestionApi.
 */
export interface IngestionApiGetTranscriptionStatusApiV1IngestionTranscribeJobIdGetRequest {
    readonly jobId: string

    readonly xApiKey?: string | null
}

/**
 * Request parameters for getWatcherStatusApiV1IngestionWatchersWatcherIdGet operation in IngestionApi.
 */
export interface IngestionApiGetWatcherStatusApiV1IngestionWatchersWatcherIdGetRequest {
    readonly watcherId: string

    readonly xApiKey?: string | null
}

/**
 * Request parameters for ingestEmailApiV1IngestionEmailIngestPost operation in IngestionApi.
 */
export interface IngestionApiIngestEmailApiV1IngestionEmailIngestPostRequest {
    readonly file: File

    readonly xApiKey?: string | null

    readonly includeAttachments?: boolean
}

/**
 * Request parameters for ingestFromUrlApiV1IngestionUrlPost operation in IngestionApi.
 */
export interface IngestionApiIngestFromUrlApiV1IngestionUrlPostRequest {
    readonly ingestUrlRequest: IngestUrlRequest

    readonly xApiKey?: string | null
}

/**
 * Request parameters for ingestStructuredDataApiV1IngestionStructuredPost operation in IngestionApi.
 */
export interface IngestionApiIngestStructuredDataApiV1IngestionStructuredPostRequest {
    readonly ingestStructuredDataRequest: IngestStructuredDataRequest

    readonly xApiKey?: string | null
}

/**
 * Request parameters for listFolderWatchersApiV1IngestionWatchersGet operation in IngestionApi.
 */
export interface IngestionApiListFolderWatchersApiV1IngestionWatchersGetRequest {
    readonly xApiKey?: string | null
}

/**
 * Request parameters for listImapAccountsApiV1IngestionEmailImapAccountsGet operation in IngestionApi.
 */
export interface IngestionApiListImapAccountsApiV1IngestionEmailImapAccountsGetRequest {
    readonly xApiKey?: string | null
}

/**
 * Request parameters for listSupportedTypesApiV1IngestionSupportedTypesGet operation in IngestionApi.
 */
export interface IngestionApiListSupportedTypesApiV1IngestionSupportedTypesGetRequest {
    readonly xApiKey?: string | null
}

/**
 * Request parameters for parseEmailApiV1IngestionEmailParsePost operation in IngestionApi.
 */
export interface IngestionApiParseEmailApiV1IngestionEmailParsePostRequest {
    readonly file: File

    readonly xApiKey?: string | null

    readonly extractActionItems?: boolean
}

/**
 * Request parameters for scanWatchedFolderApiV1IngestionWatchersWatcherIdScanPost operation in IngestionApi.
 */
export interface IngestionApiScanWatchedFolderApiV1IngestionWatchersWatcherIdScanPostRequest {
    readonly watcherId: string

    readonly xApiKey?: string | null
}

/**
 * Request parameters for startWatcherApiV1IngestionWatchersWatcherIdStartPost operation in IngestionApi.
 */
export interface IngestionApiStartWatcherApiV1IngestionWatchersWatcherIdStartPostRequest {
    readonly watcherId: string

    readonly xApiKey?: string | null
}

/**
 * Request parameters for stopWatcherApiV1IngestionWatchersWatcherIdStopPost operation in IngestionApi.
 */
export interface IngestionApiStopWatcherApiV1IngestionWatchersWatcherIdStopPostRequest {
    readonly watcherId: string

    readonly xApiKey?: string | null
}

/**
 * Request parameters for syncImapAccountApiV1IngestionEmailImapAccountsAccountIdSyncPost operation in IngestionApi.
 */
export interface IngestionApiSyncImapAccountApiV1IngestionEmailImapAccountsAccountIdSyncPostRequest {
    readonly accountId: string

    readonly xApiKey?: string | null
}

/**
 * Request parameters for transcribeFileApiV1IngestionTranscribePost operation in IngestionApi.
 */
export interface IngestionApiTranscribeFileApiV1IngestionTranscribePostRequest {
    readonly file: File

    readonly xApiKey?: string | null

    readonly diarizeSpeakers?: boolean

    readonly includeTimestamps?: boolean

    readonly language?: string

    readonly outputFormat?: string
}

/**
 * Request parameters for transcribeVoiceMemoApiV1IngestionTranscribeVoiceMemoPost operation in IngestionApi.
 */
export interface IngestionApiTranscribeVoiceMemoApiV1IngestionTranscribeVoiceMemoPostRequest {
    readonly file: File

    readonly xApiKey?: string | null

    readonly extractActionItems?: boolean

    readonly extractKeyPoints?: boolean
}

/**
 * Request parameters for uploadBulkApiV1IngestionUploadBulkPost operation in IngestionApi.
 */
export interface IngestionApiUploadBulkApiV1IngestionUploadBulkPostRequest {
    readonly files: Array<File>

    readonly xApiKey?: string | null

    readonly collection?: string

    readonly tags?: string
}

/**
 * Request parameters for uploadFileApiV1IngestionUploadPost operation in IngestionApi.
 */
export interface IngestionApiUploadFileApiV1IngestionUploadPostRequest {
    readonly file: File

    readonly xApiKey?: string | null

    readonly autoOcr?: boolean

    readonly collection?: string

    readonly generatePreview?: boolean

    readonly tags?: string
}

/**
 * Request parameters for uploadZipApiV1IngestionUploadZipPost operation in IngestionApi.
 */
export interface IngestionApiUploadZipApiV1IngestionUploadZipPostRequest {
    readonly file: File

    readonly xApiKey?: string | null

    readonly flatten?: boolean

    readonly preserveStructure?: boolean
}

/**
 * IngestionApi - object-oriented interface
 */
export class IngestionApi extends BaseAPI {
    /**
     * Clip a user-selected portion of a page.  Returns:     ClippedContent with selected content
     * @summary Clip Selection
     * @param {IngestionApiClipSelectionApiV1IngestionClipSelectionPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public clipSelectionApiV1IngestionClipSelectionPost(requestParameters: IngestionApiClipSelectionApiV1IngestionClipSelectionPostRequest, options?: RawAxiosRequestConfig) {
        return IngestionApiFp(this.configuration).clipSelectionApiV1IngestionClipSelectionPost(requestParameters.clipSelectionRequest, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Clip content from a web page.  Returns:     ClippedContent with extracted content
     * @summary Clip Web Page
     * @param {IngestionApiClipWebPageApiV1IngestionClipUrlPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public clipWebPageApiV1IngestionClipUrlPost(requestParameters: IngestionApiClipWebPageApiV1IngestionClipUrlPostRequest, options?: RawAxiosRequestConfig) {
        return IngestionApiFp(this.configuration).clipWebPageApiV1IngestionClipUrlPost(requestParameters.clipUrlRequest, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Connect an IMAP email account.  Tests the connection and stores the account configuration.  Returns:     Connection result with account ID
     * @summary Connect Imap Account
     * @param {IngestionApiConnectImapAccountApiV1IngestionEmailImapConnectPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public connectImapAccountApiV1IngestionEmailImapConnectPost(requestParameters: IngestionApiConnectImapAccountApiV1IngestionEmailImapConnectPostRequest, options?: RawAxiosRequestConfig) {
        return IngestionApiFp(this.configuration).connectImapAccountApiV1IngestionEmailImapConnectPost(requestParameters.imapConnectRequest, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new folder watcher.  Returns:     WatcherStatus
     * @summary Create Folder Watcher
     * @param {IngestionApiCreateFolderWatcherApiV1IngestionWatchersPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createFolderWatcherApiV1IngestionWatchersPost(requestParameters: IngestionApiCreateFolderWatcherApiV1IngestionWatchersPostRequest, options?: RawAxiosRequestConfig) {
        return IngestionApiFp(this.configuration).createFolderWatcherApiV1IngestionWatchersPost(requestParameters.createWatcherRequest, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a folder watcher.
     * @summary Delete Watcher
     * @param {IngestionApiDeleteWatcherApiV1IngestionWatchersWatcherIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteWatcherApiV1IngestionWatchersWatcherIdDelete(requestParameters: IngestionApiDeleteWatcherApiV1IngestionWatchersWatcherIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return IngestionApiFp(this.configuration).deleteWatcherApiV1IngestionWatchersWatcherIdDelete(requestParameters.watcherId, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Detect the type of an uploaded file.  Returns:     Detected file type and metadata
     * @summary Detect File Type
     * @param {IngestionApiDetectFileTypeApiV1IngestionDetectTypePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public detectFileTypeApiV1IngestionDetectTypePost(requestParameters: IngestionApiDetectFileTypeApiV1IngestionDetectTypePostRequest, options?: RawAxiosRequestConfig) {
        return IngestionApiFp(this.configuration).detectFileTypeApiV1IngestionDetectTypePost(requestParameters.file, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate a unique email inbox address for forwarding.  Returns:     Email address for forwarding
     * @summary Generate Inbox Address
     * @param {IngestionApiGenerateInboxAddressApiV1IngestionEmailInboxPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public generateInboxAddressApiV1IngestionEmailInboxPost(requestParameters: IngestionApiGenerateInboxAddressApiV1IngestionEmailInboxPostRequest, options?: RawAxiosRequestConfig) {
        return IngestionApiFp(this.configuration).generateInboxAddressApiV1IngestionEmailInboxPost(requestParameters.generateInboxRequest, requestParameters.userId, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the status of a transcription job.  Returns:     Job status, progress, and result when complete
     * @summary Get Transcription Status
     * @param {IngestionApiGetTranscriptionStatusApiV1IngestionTranscribeJobIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTranscriptionStatusApiV1IngestionTranscribeJobIdGet(requestParameters: IngestionApiGetTranscriptionStatusApiV1IngestionTranscribeJobIdGetRequest, options?: RawAxiosRequestConfig) {
        return IngestionApiFp(this.configuration).getTranscriptionStatusApiV1IngestionTranscribeJobIdGet(requestParameters.jobId, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get status of a folder watcher.  Returns:     WatcherStatus
     * @summary Get Watcher Status
     * @param {IngestionApiGetWatcherStatusApiV1IngestionWatchersWatcherIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getWatcherStatusApiV1IngestionWatchersWatcherIdGet(requestParameters: IngestionApiGetWatcherStatusApiV1IngestionWatchersWatcherIdGetRequest, options?: RawAxiosRequestConfig) {
        return IngestionApiFp(this.configuration).getWatcherStatusApiV1IngestionWatchersWatcherIdGet(requestParameters.watcherId, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Ingest a raw email file (.eml).  Returns:     EmailDocumentResult with created document
     * @summary Ingest Email
     * @param {IngestionApiIngestEmailApiV1IngestionEmailIngestPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ingestEmailApiV1IngestionEmailIngestPost(requestParameters: IngestionApiIngestEmailApiV1IngestionEmailIngestPostRequest, options?: RawAxiosRequestConfig) {
        return IngestionApiFp(this.configuration).ingestEmailApiV1IngestionEmailIngestPost(requestParameters.file, requestParameters.xApiKey, requestParameters.includeAttachments, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Download and ingest a file from a URL.  Returns:     IngestionResult with document details
     * @summary Ingest From Url
     * @param {IngestionApiIngestFromUrlApiV1IngestionUrlPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ingestFromUrlApiV1IngestionUrlPost(requestParameters: IngestionApiIngestFromUrlApiV1IngestionUrlPostRequest, options?: RawAxiosRequestConfig) {
        return IngestionApiFp(this.configuration).ingestFromUrlApiV1IngestionUrlPost(requestParameters.ingestUrlRequest, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Import structured data (JSON/XML/YAML) as an editable table.  Returns:     StructuredDataImport with table details
     * @summary Ingest Structured Data
     * @param {IngestionApiIngestStructuredDataApiV1IngestionStructuredPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ingestStructuredDataApiV1IngestionStructuredPost(requestParameters: IngestionApiIngestStructuredDataApiV1IngestionStructuredPostRequest, options?: RawAxiosRequestConfig) {
        return IngestionApiFp(this.configuration).ingestStructuredDataApiV1IngestionStructuredPost(requestParameters.ingestStructuredDataRequest, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all folder watchers.  Returns:     List of WatcherStatus
     * @summary List Folder Watchers
     * @param {IngestionApiListFolderWatchersApiV1IngestionWatchersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listFolderWatchersApiV1IngestionWatchersGet(requestParameters: IngestionApiListFolderWatchersApiV1IngestionWatchersGetRequest = {}, options?: RawAxiosRequestConfig) {
        return IngestionApiFp(this.configuration).listFolderWatchersApiV1IngestionWatchersGet(requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List connected IMAP email accounts.  Returns:     List of connected IMAP accounts
     * @summary List Imap Accounts
     * @param {IngestionApiListImapAccountsApiV1IngestionEmailImapAccountsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listImapAccountsApiV1IngestionEmailImapAccountsGet(requestParameters: IngestionApiListImapAccountsApiV1IngestionEmailImapAccountsGetRequest = {}, options?: RawAxiosRequestConfig) {
        return IngestionApiFp(this.configuration).listImapAccountsApiV1IngestionEmailImapAccountsGet(requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all supported file types for ingestion.  Returns:     List of supported file types
     * @summary List Supported Types
     * @param {IngestionApiListSupportedTypesApiV1IngestionSupportedTypesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listSupportedTypesApiV1IngestionSupportedTypesGet(requestParameters: IngestionApiListSupportedTypesApiV1IngestionSupportedTypesGetRequest = {}, options?: RawAxiosRequestConfig) {
        return IngestionApiFp(this.configuration).listSupportedTypesApiV1IngestionSupportedTypesGet(requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Parse an email and extract structured data.  Returns:     Parsed email with action items and links
     * @summary Parse Email
     * @param {IngestionApiParseEmailApiV1IngestionEmailParsePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public parseEmailApiV1IngestionEmailParsePost(requestParameters: IngestionApiParseEmailApiV1IngestionEmailParsePostRequest, options?: RawAxiosRequestConfig) {
        return IngestionApiFp(this.configuration).parseEmailApiV1IngestionEmailParsePost(requestParameters.file, requestParameters.xApiKey, requestParameters.extractActionItems, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Manually scan a watched folder for existing files.  Returns:     List of FileEvents
     * @summary Scan Watched Folder
     * @param {IngestionApiScanWatchedFolderApiV1IngestionWatchersWatcherIdScanPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public scanWatchedFolderApiV1IngestionWatchersWatcherIdScanPost(requestParameters: IngestionApiScanWatchedFolderApiV1IngestionWatchersWatcherIdScanPostRequest, options?: RawAxiosRequestConfig) {
        return IngestionApiFp(this.configuration).scanWatchedFolderApiV1IngestionWatchersWatcherIdScanPost(requestParameters.watcherId, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start a folder watcher.
     * @summary Start Watcher
     * @param {IngestionApiStartWatcherApiV1IngestionWatchersWatcherIdStartPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public startWatcherApiV1IngestionWatchersWatcherIdStartPost(requestParameters: IngestionApiStartWatcherApiV1IngestionWatchersWatcherIdStartPostRequest, options?: RawAxiosRequestConfig) {
        return IngestionApiFp(this.configuration).startWatcherApiV1IngestionWatchersWatcherIdStartPost(requestParameters.watcherId, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Stop a folder watcher.
     * @summary Stop Watcher
     * @param {IngestionApiStopWatcherApiV1IngestionWatchersWatcherIdStopPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public stopWatcherApiV1IngestionWatchersWatcherIdStopPost(requestParameters: IngestionApiStopWatcherApiV1IngestionWatchersWatcherIdStopPostRequest, options?: RawAxiosRequestConfig) {
        return IngestionApiFp(this.configuration).stopWatcherApiV1IngestionWatchersWatcherIdStopPost(requestParameters.watcherId, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sync emails from an IMAP account.  Triggers email synchronisation for the specified account.  Returns:     Sync job status
     * @summary Sync Imap Account
     * @param {IngestionApiSyncImapAccountApiV1IngestionEmailImapAccountsAccountIdSyncPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public syncImapAccountApiV1IngestionEmailImapAccountsAccountIdSyncPost(requestParameters: IngestionApiSyncImapAccountApiV1IngestionEmailImapAccountsAccountIdSyncPostRequest, options?: RawAxiosRequestConfig) {
        return IngestionApiFp(this.configuration).syncImapAccountApiV1IngestionEmailImapAccountsAccountIdSyncPost(requestParameters.accountId, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Transcribe an audio or video file.  Returns:     TranscriptionResult with full transcript
     * @summary Transcribe File
     * @param {IngestionApiTranscribeFileApiV1IngestionTranscribePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public transcribeFileApiV1IngestionTranscribePost(requestParameters: IngestionApiTranscribeFileApiV1IngestionTranscribePostRequest, options?: RawAxiosRequestConfig) {
        return IngestionApiFp(this.configuration).transcribeFileApiV1IngestionTranscribePost(requestParameters.file, requestParameters.xApiKey, requestParameters.diarizeSpeakers, requestParameters.includeTimestamps, requestParameters.language, requestParameters.outputFormat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Transcribe a voice memo with intelligent extraction.  Returns:     VoiceMemoResult with transcript and extracted items
     * @summary Transcribe Voice Memo
     * @param {IngestionApiTranscribeVoiceMemoApiV1IngestionTranscribeVoiceMemoPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public transcribeVoiceMemoApiV1IngestionTranscribeVoiceMemoPost(requestParameters: IngestionApiTranscribeVoiceMemoApiV1IngestionTranscribeVoiceMemoPostRequest, options?: RawAxiosRequestConfig) {
        return IngestionApiFp(this.configuration).transcribeVoiceMemoApiV1IngestionTranscribeVoiceMemoPost(requestParameters.file, requestParameters.xApiKey, requestParameters.extractActionItems, requestParameters.extractKeyPoints, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload multiple files at once.  Returns:     List of IngestionResults
     * @summary Upload Bulk
     * @param {IngestionApiUploadBulkApiV1IngestionUploadBulkPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public uploadBulkApiV1IngestionUploadBulkPost(requestParameters: IngestionApiUploadBulkApiV1IngestionUploadBulkPostRequest, options?: RawAxiosRequestConfig) {
        return IngestionApiFp(this.configuration).uploadBulkApiV1IngestionUploadBulkPost(requestParameters.files, requestParameters.xApiKey, requestParameters.collection, requestParameters.tags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload and ingest a file with auto-detection.  Returns:     IngestionResult with document details
     * @summary Upload File
     * @param {IngestionApiUploadFileApiV1IngestionUploadPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public uploadFileApiV1IngestionUploadPost(requestParameters: IngestionApiUploadFileApiV1IngestionUploadPostRequest, options?: RawAxiosRequestConfig) {
        return IngestionApiFp(this.configuration).uploadFileApiV1IngestionUploadPost(requestParameters.file, requestParameters.xApiKey, requestParameters.autoOcr, requestParameters.collection, requestParameters.generatePreview, requestParameters.tags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload and extract a ZIP archive.  Returns:     BulkIngestionResult with all extracted documents
     * @summary Upload Zip
     * @param {IngestionApiUploadZipApiV1IngestionUploadZipPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public uploadZipApiV1IngestionUploadZipPost(requestParameters: IngestionApiUploadZipApiV1IngestionUploadZipPostRequest, options?: RawAxiosRequestConfig) {
        return IngestionApiFp(this.configuration).uploadZipApiV1IngestionUploadZipPost(requestParameters.file, requestParameters.xApiKey, requestParameters.flatten, requestParameters.preserveStructure, options).then((request) => request(this.axios, this.basePath));
    }
}

