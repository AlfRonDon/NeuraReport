/* tslint:disable */
/* eslint-disable */
/**
 * NeuraReport API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 4.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, replaceWithSerializableTypeIfNeeded } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { ConnectionResponse } from '../models';
// @ts-ignore
import type { ConnectorInfo } from '../models';
// @ts-ignore
import type { CreateConnectionRequest } from '../models';
// @ts-ignore
import type { FileUploadResponse } from '../models';
// @ts-ignore
import type { HTTPValidationError } from '../models';
// @ts-ignore
import type { QueryRequest } from '../models';
// @ts-ignore
import type { QueryResponse } from '../models';
// @ts-ignore
import type { SyncScheduleRequest } from '../models';
// @ts-ignore
import type { SyncScheduleResponse } from '../models';
// @ts-ignore
import type { SyncStatusResponse } from '../models';
// @ts-ignore
import type { TestConnectionRequest } from '../models';
// @ts-ignore
import type { TestConnectionResponse } from '../models';
/**
 * ConnectorsApi - axios parameter creator
 */
export const ConnectorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Check if a connection is healthy.
         * @summary Check Connection Health
         * @param {string} connectionId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkConnectionHealthApiV1ConnectorsConnectionIdHealthPost: async (connectionId: string, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('checkConnectionHealthApiV1ConnectorsConnectionIdHealthPost', 'connectionId', connectionId)
            const localVarPath = `/api/v1/connectors/{connection_id}/health`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if a connection is healthy.
         * @summary Check Connection Health
         * @param {string} connectionId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkConnectionHealthApiV1ConnectorsConnectionIdHealthPost_1: async (connectionId: string, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('checkConnectionHealthApiV1ConnectorsConnectionIdHealthPost_1', 'connectionId', connectionId)
            const localVarPath = `/api/v1/connectors/{connection_id}/health`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create and save a new connection.
         * @summary Create Connection
         * @param {string} connectorType 
         * @param {CreateConnectionRequest} createConnectionRequest 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnectionApiV1ConnectorsConnectorTypeConnectPost: async (connectorType: string, createConnectionRequest: CreateConnectionRequest, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorType' is not null or undefined
            assertParamExists('createConnectionApiV1ConnectorsConnectorTypeConnectPost', 'connectorType', connectorType)
            // verify required parameter 'createConnectionRequest' is not null or undefined
            assertParamExists('createConnectionApiV1ConnectorsConnectorTypeConnectPost', 'createConnectionRequest', createConnectionRequest)
            const localVarPath = `/api/v1/connectors/{connector_type}/connect`
                .replace(`{${"connector_type"}}`, encodeURIComponent(String(connectorType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createConnectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create and save a new connection.
         * @summary Create Connection
         * @param {string} connectorType 
         * @param {CreateConnectionRequest} createConnectionRequest 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnectionApiV1ConnectorsConnectorTypeConnectPost_2: async (connectorType: string, createConnectionRequest: CreateConnectionRequest, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorType' is not null or undefined
            assertParamExists('createConnectionApiV1ConnectorsConnectorTypeConnectPost_2', 'connectorType', connectorType)
            // verify required parameter 'createConnectionRequest' is not null or undefined
            assertParamExists('createConnectionApiV1ConnectorsConnectorTypeConnectPost_2', 'createConnectionRequest', createConnectionRequest)
            const localVarPath = `/api/v1/connectors/{connector_type}/connect`
                .replace(`{${"connector_type"}}`, encodeURIComponent(String(connectorType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createConnectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a connection.
         * @summary Delete Connection
         * @param {string} connectionId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnectionApiV1ConnectorsConnectionIdDelete: async (connectionId: string, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('deleteConnectionApiV1ConnectorsConnectionIdDelete', 'connectionId', connectionId)
            const localVarPath = `/api/v1/connectors/{connection_id}`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a connection.
         * @summary Delete Connection
         * @param {string} connectionId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnectionApiV1ConnectorsConnectionIdDelete_3: async (connectionId: string, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('deleteConnectionApiV1ConnectorsConnectionIdDelete_3', 'connectionId', connectionId)
            const localVarPath = `/api/v1/connectors/{connection_id}`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Download a file from a cloud storage connection.  The *path* query parameter identifies the file to download.  The response streams the raw file bytes with an appropriate content type.
         * @summary Download Connection File
         * @param {string} connectionId 
         * @param {string} path 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadConnectionFileApiV1ConnectorsConnectionIdFilesDownloadGet: async (connectionId: string, path: string, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('downloadConnectionFileApiV1ConnectorsConnectionIdFilesDownloadGet', 'connectionId', connectionId)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('downloadConnectionFileApiV1ConnectorsConnectionIdFilesDownloadGet', 'path', path)
            const localVarPath = `/api/v1/connectors/{connection_id}/files/download`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Download a file from a cloud storage connection.  The *path* query parameter identifies the file to download.  The response streams the raw file bytes with an appropriate content type.
         * @summary Download Connection File
         * @param {string} connectionId 
         * @param {string} path 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadConnectionFileApiV1ConnectorsConnectionIdFilesDownloadGet_4: async (connectionId: string, path: string, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('downloadConnectionFileApiV1ConnectorsConnectionIdFilesDownloadGet_4', 'connectionId', connectionId)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('downloadConnectionFileApiV1ConnectorsConnectionIdFilesDownloadGet_4', 'path', path)
            const localVarPath = `/api/v1/connectors/{connection_id}/files/download`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Execute a query on a connection.
         * @summary Execute Query
         * @param {string} connectionId 
         * @param {QueryRequest} queryRequest 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeQueryApiV1ConnectorsConnectionIdQueryPost: async (connectionId: string, queryRequest: QueryRequest, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('executeQueryApiV1ConnectorsConnectionIdQueryPost', 'connectionId', connectionId)
            // verify required parameter 'queryRequest' is not null or undefined
            assertParamExists('executeQueryApiV1ConnectorsConnectionIdQueryPost', 'queryRequest', queryRequest)
            const localVarPath = `/api/v1/connectors/{connection_id}/query`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Execute a query on a connection.
         * @summary Execute Query
         * @param {string} connectionId 
         * @param {QueryRequest} queryRequest 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeQueryApiV1ConnectorsConnectionIdQueryPost_5: async (connectionId: string, queryRequest: QueryRequest, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('executeQueryApiV1ConnectorsConnectionIdQueryPost_5', 'connectionId', connectionId)
            // verify required parameter 'queryRequest' is not null or undefined
            assertParamExists('executeQueryApiV1ConnectorsConnectionIdQueryPost_5', 'queryRequest', queryRequest)
            const localVarPath = `/api/v1/connectors/{connection_id}/query`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a connection by ID.  Note: connection_id is restricted to UUID format to disambiguate from /{connector_type}/... routes which use short alphanumeric names.
         * @summary Get Connection
         * @param {string} connectionId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionApiV1ConnectorsConnectionIdGet: async (connectionId: string, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('getConnectionApiV1ConnectorsConnectionIdGet', 'connectionId', connectionId)
            const localVarPath = `/api/v1/connectors/{connection_id}`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a connection by ID.  Note: connection_id is restricted to UUID format to disambiguate from /{connector_type}/... routes which use short alphanumeric names.
         * @summary Get Connection
         * @param {string} connectionId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionApiV1ConnectorsConnectionIdGet_6: async (connectionId: string, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('getConnectionApiV1ConnectorsConnectionIdGet_6', 'connectionId', connectionId)
            const localVarPath = `/api/v1/connectors/{connection_id}`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get schema information for a connection.
         * @summary Get Connection Schema
         * @param {string} connectionId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionSchemaApiV1ConnectorsConnectionIdSchemaGet: async (connectionId: string, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('getConnectionSchemaApiV1ConnectorsConnectionIdSchemaGet', 'connectionId', connectionId)
            const localVarPath = `/api/v1/connectors/{connection_id}/schema`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get schema information for a connection.
         * @summary Get Connection Schema
         * @param {string} connectionId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionSchemaApiV1ConnectorsConnectionIdSchemaGet_7: async (connectionId: string, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('getConnectionSchemaApiV1ConnectorsConnectionIdSchemaGet_7', 'connectionId', connectionId)
            const localVarPath = `/api/v1/connectors/{connection_id}/schema`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about a specific connector type.
         * @summary Get Connector Type
         * @param {string} connectorType 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorTypeApiV1ConnectorsTypesConnectorTypeGet: async (connectorType: string, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorType' is not null or undefined
            assertParamExists('getConnectorTypeApiV1ConnectorsTypesConnectorTypeGet', 'connectorType', connectorType)
            const localVarPath = `/api/v1/connectors/types/{connector_type}`
                .replace(`{${"connector_type"}}`, encodeURIComponent(String(connectorType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about a specific connector type.
         * @summary Get Connector Type
         * @param {string} connectorType 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorTypeApiV1ConnectorsTypesConnectorTypeGet_8: async (connectorType: string, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorType' is not null or undefined
            assertParamExists('getConnectorTypeApiV1ConnectorsTypesConnectorTypeGet_8', 'connectorType', connectorType)
            const localVarPath = `/api/v1/connectors/types/{connector_type}`
                .replace(`{${"connector_type"}}`, encodeURIComponent(String(connectorType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get OAuth authorization URL for a connector.
         * @summary Get Oauth Url
         * @param {string} connectorType 
         * @param {string} redirectUri 
         * @param {string | null} [state] 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOauthUrlApiV1ConnectorsConnectorTypeOauthAuthorizeGet: async (connectorType: string, redirectUri: string, state?: string | null, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorType' is not null or undefined
            assertParamExists('getOauthUrlApiV1ConnectorsConnectorTypeOauthAuthorizeGet', 'connectorType', connectorType)
            // verify required parameter 'redirectUri' is not null or undefined
            assertParamExists('getOauthUrlApiV1ConnectorsConnectorTypeOauthAuthorizeGet', 'redirectUri', redirectUri)
            const localVarPath = `/api/v1/connectors/{connector_type}/oauth/authorize`
                .replace(`{${"connector_type"}}`, encodeURIComponent(String(connectorType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (redirectUri !== undefined) {
                localVarQueryParameter['redirect_uri'] = redirectUri;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get OAuth authorization URL for a connector.
         * @summary Get Oauth Url
         * @param {string} connectorType 
         * @param {string} redirectUri 
         * @param {string | null} [state] 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOauthUrlApiV1ConnectorsConnectorTypeOauthAuthorizeGet_9: async (connectorType: string, redirectUri: string, state?: string | null, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorType' is not null or undefined
            assertParamExists('getOauthUrlApiV1ConnectorsConnectorTypeOauthAuthorizeGet_9', 'connectorType', connectorType)
            // verify required parameter 'redirectUri' is not null or undefined
            assertParamExists('getOauthUrlApiV1ConnectorsConnectorTypeOauthAuthorizeGet_9', 'redirectUri', redirectUri)
            const localVarPath = `/api/v1/connectors/{connector_type}/oauth/authorize`
                .replace(`{${"connector_type"}}`, encodeURIComponent(String(connectorType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (redirectUri !== undefined) {
                localVarQueryParameter['redirect_uri'] = redirectUri;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the sync status for a connection.  Returns the most recent sync status from the state store.  If no sync has been run yet, a ``never_synced`` status is returned.
         * @summary Get Sync Status
         * @param {string} connectionId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSyncStatusApiV1ConnectorsConnectionIdSyncStatusGet: async (connectionId: string, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('getSyncStatusApiV1ConnectorsConnectionIdSyncStatusGet', 'connectionId', connectionId)
            const localVarPath = `/api/v1/connectors/{connection_id}/sync/status`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the sync status for a connection.  Returns the most recent sync status from the state store.  If no sync has been run yet, a ``never_synced`` status is returned.
         * @summary Get Sync Status
         * @param {string} connectionId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSyncStatusApiV1ConnectorsConnectionIdSyncStatusGet_10: async (connectionId: string, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('getSyncStatusApiV1ConnectorsConnectionIdSyncStatusGet_10', 'connectionId', connectionId)
            const localVarPath = `/api/v1/connectors/{connection_id}/sync/status`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Handle OAuth callback and exchange code for tokens.
         * @summary Handle Oauth Callback
         * @param {string} connectorType 
         * @param {string} code 
         * @param {string} redirectUri 
         * @param {string | null} [state] 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleOauthCallbackApiV1ConnectorsConnectorTypeOauthCallbackPost: async (connectorType: string, code: string, redirectUri: string, state?: string | null, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorType' is not null or undefined
            assertParamExists('handleOauthCallbackApiV1ConnectorsConnectorTypeOauthCallbackPost', 'connectorType', connectorType)
            // verify required parameter 'code' is not null or undefined
            assertParamExists('handleOauthCallbackApiV1ConnectorsConnectorTypeOauthCallbackPost', 'code', code)
            // verify required parameter 'redirectUri' is not null or undefined
            assertParamExists('handleOauthCallbackApiV1ConnectorsConnectorTypeOauthCallbackPost', 'redirectUri', redirectUri)
            const localVarPath = `/api/v1/connectors/{connector_type}/oauth/callback`
                .replace(`{${"connector_type"}}`, encodeURIComponent(String(connectorType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (redirectUri !== undefined) {
                localVarQueryParameter['redirect_uri'] = redirectUri;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Handle OAuth callback and exchange code for tokens.
         * @summary Handle Oauth Callback
         * @param {string} connectorType 
         * @param {string} code 
         * @param {string} redirectUri 
         * @param {string | null} [state] 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleOauthCallbackApiV1ConnectorsConnectorTypeOauthCallbackPost_11: async (connectorType: string, code: string, redirectUri: string, state?: string | null, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorType' is not null or undefined
            assertParamExists('handleOauthCallbackApiV1ConnectorsConnectorTypeOauthCallbackPost_11', 'connectorType', connectorType)
            // verify required parameter 'code' is not null or undefined
            assertParamExists('handleOauthCallbackApiV1ConnectorsConnectorTypeOauthCallbackPost_11', 'code', code)
            // verify required parameter 'redirectUri' is not null or undefined
            assertParamExists('handleOauthCallbackApiV1ConnectorsConnectorTypeOauthCallbackPost_11', 'redirectUri', redirectUri)
            const localVarPath = `/api/v1/connectors/{connector_type}/oauth/callback`
                .replace(`{${"connector_type"}}`, encodeURIComponent(String(connectorType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (redirectUri !== undefined) {
                localVarQueryParameter['redirect_uri'] = redirectUri;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List files for a cloud storage connection.  Returns files and folders at the given *path* within the connected cloud storage provider.
         * @summary List Connection Files
         * @param {string} connectionId 
         * @param {string} [path] 
         * @param {boolean} [recursive] 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnectionFilesApiV1ConnectorsConnectionIdFilesGet: async (connectionId: string, path?: string, recursive?: boolean, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('listConnectionFilesApiV1ConnectorsConnectionIdFilesGet', 'connectionId', connectionId)
            const localVarPath = `/api/v1/connectors/{connection_id}/files`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (recursive !== undefined) {
                localVarQueryParameter['recursive'] = recursive;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List files for a cloud storage connection.  Returns files and folders at the given *path* within the connected cloud storage provider.
         * @summary List Connection Files
         * @param {string} connectionId 
         * @param {string} [path] 
         * @param {boolean} [recursive] 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnectionFilesApiV1ConnectorsConnectionIdFilesGet_12: async (connectionId: string, path?: string, recursive?: boolean, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('listConnectionFilesApiV1ConnectorsConnectionIdFilesGet_12', 'connectionId', connectionId)
            const localVarPath = `/api/v1/connectors/{connection_id}/files`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (recursive !== undefined) {
                localVarQueryParameter['recursive'] = recursive;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List saved connections.
         * @summary List Connections
         * @param {string | null} [connectorType] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnectionsApiV1ConnectorsGet: async (connectorType?: string | null, limit?: number, offset?: number, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/connectors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (connectorType !== undefined) {
                localVarQueryParameter['connector_type'] = connectorType;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List saved connections.
         * @summary List Connections
         * @param {string | null} [connectorType] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnectionsApiV1ConnectorsGet_13: async (connectorType?: string | null, limit?: number, offset?: number, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/connectors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (connectorType !== undefined) {
                localVarQueryParameter['connector_type'] = connectorType;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all available connector types.
         * @summary List Connector Types
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnectorTypesApiV1ConnectorsTypesGet: async (xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/connectors/types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all available connector types.
         * @summary List Connector Types
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnectorTypesApiV1ConnectorsTypesGet_14: async (xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/connectors/types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List connectors by category.
         * @summary List Connectors By Category
         * @param {string} category 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnectorsByCategoryApiV1ConnectorsTypesByCategoryCategoryGet: async (category: string, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'category' is not null or undefined
            assertParamExists('listConnectorsByCategoryApiV1ConnectorsTypesByCategoryCategoryGet', 'category', category)
            const localVarPath = `/api/v1/connectors/types/by-category/{category}`
                .replace(`{${"category"}}`, encodeURIComponent(String(category)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List connectors by category.
         * @summary List Connectors By Category
         * @param {string} category 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnectorsByCategoryApiV1ConnectorsTypesByCategoryCategoryGet_15: async (category: string, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'category' is not null or undefined
            assertParamExists('listConnectorsByCategoryApiV1ConnectorsTypesByCategoryCategoryGet_15', 'category', category)
            const localVarPath = `/api/v1/connectors/types/by-category/{category}`
                .replace(`{${"category"}}`, encodeURIComponent(String(category)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Schedule periodic sync for a connection.  Stores the schedule configuration in the state store under ``connector_sync_status`` so that a background worker can pick it up.  The *interval_minutes* field must be between 5 and 1440 (24h).
         * @summary Schedule Connection Sync
         * @param {string} connectionId 
         * @param {SyncScheduleRequest} syncScheduleRequest 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleConnectionSyncApiV1ConnectorsConnectionIdSyncSchedulePost: async (connectionId: string, syncScheduleRequest: SyncScheduleRequest, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('scheduleConnectionSyncApiV1ConnectorsConnectionIdSyncSchedulePost', 'connectionId', connectionId)
            // verify required parameter 'syncScheduleRequest' is not null or undefined
            assertParamExists('scheduleConnectionSyncApiV1ConnectorsConnectionIdSyncSchedulePost', 'syncScheduleRequest', syncScheduleRequest)
            const localVarPath = `/api/v1/connectors/{connection_id}/sync/schedule`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(syncScheduleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Schedule periodic sync for a connection.  Stores the schedule configuration in the state store under ``connector_sync_status`` so that a background worker can pick it up.  The *interval_minutes* field must be between 5 and 1440 (24h).
         * @summary Schedule Connection Sync
         * @param {string} connectionId 
         * @param {SyncScheduleRequest} syncScheduleRequest 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleConnectionSyncApiV1ConnectorsConnectionIdSyncSchedulePost_16: async (connectionId: string, syncScheduleRequest: SyncScheduleRequest, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('scheduleConnectionSyncApiV1ConnectorsConnectionIdSyncSchedulePost_16', 'connectionId', connectionId)
            // verify required parameter 'syncScheduleRequest' is not null or undefined
            assertParamExists('scheduleConnectionSyncApiV1ConnectorsConnectionIdSyncSchedulePost_16', 'syncScheduleRequest', syncScheduleRequest)
            const localVarPath = `/api/v1/connectors/{connection_id}/sync/schedule`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(syncScheduleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start syncing a connection.  Initiates a sync operation for the connection and records the sync status in the persistent state store under ``connector_sync_status``.
         * @summary Start Connection Sync
         * @param {string} connectionId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startConnectionSyncApiV1ConnectorsConnectionIdSyncPost: async (connectionId: string, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('startConnectionSyncApiV1ConnectorsConnectionIdSyncPost', 'connectionId', connectionId)
            const localVarPath = `/api/v1/connectors/{connection_id}/sync`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start syncing a connection.  Initiates a sync operation for the connection and records the sync status in the persistent state store under ``connector_sync_status``.
         * @summary Start Connection Sync
         * @param {string} connectionId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startConnectionSyncApiV1ConnectorsConnectionIdSyncPost_17: async (connectionId: string, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('startConnectionSyncApiV1ConnectorsConnectionIdSyncPost_17', 'connectionId', connectionId)
            const localVarPath = `/api/v1/connectors/{connection_id}/sync`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test a connection configuration.
         * @summary Test Connection
         * @param {string} connectorType 
         * @param {TestConnectionRequest} testConnectionRequest 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testConnectionApiV1ConnectorsConnectorTypeTestPost: async (connectorType: string, testConnectionRequest: TestConnectionRequest, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorType' is not null or undefined
            assertParamExists('testConnectionApiV1ConnectorsConnectorTypeTestPost', 'connectorType', connectorType)
            // verify required parameter 'testConnectionRequest' is not null or undefined
            assertParamExists('testConnectionApiV1ConnectorsConnectorTypeTestPost', 'testConnectionRequest', testConnectionRequest)
            const localVarPath = `/api/v1/connectors/{connector_type}/test`
                .replace(`{${"connector_type"}}`, encodeURIComponent(String(connectorType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(testConnectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test a connection configuration.
         * @summary Test Connection
         * @param {string} connectorType 
         * @param {TestConnectionRequest} testConnectionRequest 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testConnectionApiV1ConnectorsConnectorTypeTestPost_18: async (connectorType: string, testConnectionRequest: TestConnectionRequest, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorType' is not null or undefined
            assertParamExists('testConnectionApiV1ConnectorsConnectorTypeTestPost_18', 'connectorType', connectorType)
            // verify required parameter 'testConnectionRequest' is not null or undefined
            assertParamExists('testConnectionApiV1ConnectorsConnectorTypeTestPost_18', 'testConnectionRequest', testConnectionRequest)
            const localVarPath = `/api/v1/connectors/{connector_type}/test`
                .replace(`{${"connector_type"}}`, encodeURIComponent(String(connectorType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(testConnectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a file to a cloud storage connection.  Accepts a multipart file upload and stores it at the given *path* within the connected cloud storage provider.
         * @summary Upload Connection File
         * @param {string} connectionId 
         * @param {File} file 
         * @param {string} [path] 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadConnectionFileApiV1ConnectorsConnectionIdFilesUploadPost: async (connectionId: string, file: File, path?: string, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('uploadConnectionFileApiV1ConnectorsConnectionIdFilesUploadPost', 'connectionId', connectionId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadConnectionFileApiV1ConnectorsConnectionIdFilesUploadPost', 'file', file)
            const localVarPath = `/api/v1/connectors/{connection_id}/files/upload`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a file to a cloud storage connection.  Accepts a multipart file upload and stores it at the given *path* within the connected cloud storage provider.
         * @summary Upload Connection File
         * @param {string} connectionId 
         * @param {File} file 
         * @param {string} [path] 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadConnectionFileApiV1ConnectorsConnectionIdFilesUploadPost_19: async (connectionId: string, file: File, path?: string, xApiKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('uploadConnectionFileApiV1ConnectorsConnectionIdFilesUploadPost_19', 'connectionId', connectionId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadConnectionFileApiV1ConnectorsConnectionIdFilesUploadPost_19', 'file', file)
            const localVarPath = `/api/v1/connectors/{connection_id}/files/upload`
                .replace(`{${"connection_id"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarHeaderParameter['Accept'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConnectorsApi - functional programming interface
 */
export const ConnectorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConnectorsApiAxiosParamCreator(configuration)
    return {
        /**
         * Check if a connection is healthy.
         * @summary Check Connection Health
         * @param {string} connectionId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkConnectionHealthApiV1ConnectorsConnectionIdHealthPost(connectionId: string, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestConnectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkConnectionHealthApiV1ConnectorsConnectionIdHealthPost(connectionId, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.checkConnectionHealthApiV1ConnectorsConnectionIdHealthPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Check if a connection is healthy.
         * @summary Check Connection Health
         * @param {string} connectionId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkConnectionHealthApiV1ConnectorsConnectionIdHealthPost_1(connectionId: string, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestConnectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkConnectionHealthApiV1ConnectorsConnectionIdHealthPost_1(connectionId, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.checkConnectionHealthApiV1ConnectorsConnectionIdHealthPost_1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create and save a new connection.
         * @summary Create Connection
         * @param {string} connectorType 
         * @param {CreateConnectionRequest} createConnectionRequest 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConnectionApiV1ConnectorsConnectorTypeConnectPost(connectorType: string, createConnectionRequest: CreateConnectionRequest, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConnectionApiV1ConnectorsConnectorTypeConnectPost(connectorType, createConnectionRequest, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.createConnectionApiV1ConnectorsConnectorTypeConnectPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create and save a new connection.
         * @summary Create Connection
         * @param {string} connectorType 
         * @param {CreateConnectionRequest} createConnectionRequest 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConnectionApiV1ConnectorsConnectorTypeConnectPost_2(connectorType: string, createConnectionRequest: CreateConnectionRequest, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConnectionApiV1ConnectorsConnectorTypeConnectPost_2(connectorType, createConnectionRequest, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.createConnectionApiV1ConnectorsConnectorTypeConnectPost_2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a connection.
         * @summary Delete Connection
         * @param {string} connectionId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConnectionApiV1ConnectorsConnectionIdDelete(connectionId: string, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConnectionApiV1ConnectorsConnectionIdDelete(connectionId, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.deleteConnectionApiV1ConnectorsConnectionIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a connection.
         * @summary Delete Connection
         * @param {string} connectionId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConnectionApiV1ConnectorsConnectionIdDelete_3(connectionId: string, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConnectionApiV1ConnectorsConnectionIdDelete_3(connectionId, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.deleteConnectionApiV1ConnectorsConnectionIdDelete_3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Download a file from a cloud storage connection.  The *path* query parameter identifies the file to download.  The response streams the raw file bytes with an appropriate content type.
         * @summary Download Connection File
         * @param {string} connectionId 
         * @param {string} path 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadConnectionFileApiV1ConnectorsConnectionIdFilesDownloadGet(connectionId: string, path: string, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadConnectionFileApiV1ConnectorsConnectionIdFilesDownloadGet(connectionId, path, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.downloadConnectionFileApiV1ConnectorsConnectionIdFilesDownloadGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Download a file from a cloud storage connection.  The *path* query parameter identifies the file to download.  The response streams the raw file bytes with an appropriate content type.
         * @summary Download Connection File
         * @param {string} connectionId 
         * @param {string} path 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadConnectionFileApiV1ConnectorsConnectionIdFilesDownloadGet_4(connectionId: string, path: string, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadConnectionFileApiV1ConnectorsConnectionIdFilesDownloadGet_4(connectionId, path, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.downloadConnectionFileApiV1ConnectorsConnectionIdFilesDownloadGet_4']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Execute a query on a connection.
         * @summary Execute Query
         * @param {string} connectionId 
         * @param {QueryRequest} queryRequest 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeQueryApiV1ConnectorsConnectionIdQueryPost(connectionId: string, queryRequest: QueryRequest, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeQueryApiV1ConnectorsConnectionIdQueryPost(connectionId, queryRequest, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.executeQueryApiV1ConnectorsConnectionIdQueryPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Execute a query on a connection.
         * @summary Execute Query
         * @param {string} connectionId 
         * @param {QueryRequest} queryRequest 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeQueryApiV1ConnectorsConnectionIdQueryPost_5(connectionId: string, queryRequest: QueryRequest, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeQueryApiV1ConnectorsConnectionIdQueryPost_5(connectionId, queryRequest, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.executeQueryApiV1ConnectorsConnectionIdQueryPost_5']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a connection by ID.  Note: connection_id is restricted to UUID format to disambiguate from /{connector_type}/... routes which use short alphanumeric names.
         * @summary Get Connection
         * @param {string} connectionId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectionApiV1ConnectorsConnectionIdGet(connectionId: string, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnectionApiV1ConnectorsConnectionIdGet(connectionId, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.getConnectionApiV1ConnectorsConnectionIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a connection by ID.  Note: connection_id is restricted to UUID format to disambiguate from /{connector_type}/... routes which use short alphanumeric names.
         * @summary Get Connection
         * @param {string} connectionId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectionApiV1ConnectorsConnectionIdGet_6(connectionId: string, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnectionApiV1ConnectorsConnectionIdGet_6(connectionId, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.getConnectionApiV1ConnectorsConnectionIdGet_6']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get schema information for a connection.
         * @summary Get Connection Schema
         * @param {string} connectionId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectionSchemaApiV1ConnectorsConnectionIdSchemaGet(connectionId: string, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnectionSchemaApiV1ConnectorsConnectionIdSchemaGet(connectionId, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.getConnectionSchemaApiV1ConnectorsConnectionIdSchemaGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get schema information for a connection.
         * @summary Get Connection Schema
         * @param {string} connectionId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectionSchemaApiV1ConnectorsConnectionIdSchemaGet_7(connectionId: string, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnectionSchemaApiV1ConnectorsConnectionIdSchemaGet_7(connectionId, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.getConnectionSchemaApiV1ConnectorsConnectionIdSchemaGet_7']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information about a specific connector type.
         * @summary Get Connector Type
         * @param {string} connectorType 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectorTypeApiV1ConnectorsTypesConnectorTypeGet(connectorType: string, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnectorTypeApiV1ConnectorsTypesConnectorTypeGet(connectorType, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.getConnectorTypeApiV1ConnectorsTypesConnectorTypeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information about a specific connector type.
         * @summary Get Connector Type
         * @param {string} connectorType 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectorTypeApiV1ConnectorsTypesConnectorTypeGet_8(connectorType: string, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnectorTypeApiV1ConnectorsTypesConnectorTypeGet_8(connectorType, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.getConnectorTypeApiV1ConnectorsTypesConnectorTypeGet_8']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get OAuth authorization URL for a connector.
         * @summary Get Oauth Url
         * @param {string} connectorType 
         * @param {string} redirectUri 
         * @param {string | null} [state] 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOauthUrlApiV1ConnectorsConnectorTypeOauthAuthorizeGet(connectorType: string, redirectUri: string, state?: string | null, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOauthUrlApiV1ConnectorsConnectorTypeOauthAuthorizeGet(connectorType, redirectUri, state, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.getOauthUrlApiV1ConnectorsConnectorTypeOauthAuthorizeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get OAuth authorization URL for a connector.
         * @summary Get Oauth Url
         * @param {string} connectorType 
         * @param {string} redirectUri 
         * @param {string | null} [state] 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOauthUrlApiV1ConnectorsConnectorTypeOauthAuthorizeGet_9(connectorType: string, redirectUri: string, state?: string | null, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOauthUrlApiV1ConnectorsConnectorTypeOauthAuthorizeGet_9(connectorType, redirectUri, state, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.getOauthUrlApiV1ConnectorsConnectorTypeOauthAuthorizeGet_9']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the sync status for a connection.  Returns the most recent sync status from the state store.  If no sync has been run yet, a ``never_synced`` status is returned.
         * @summary Get Sync Status
         * @param {string} connectionId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSyncStatusApiV1ConnectorsConnectionIdSyncStatusGet(connectionId: string, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SyncStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSyncStatusApiV1ConnectorsConnectionIdSyncStatusGet(connectionId, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.getSyncStatusApiV1ConnectorsConnectionIdSyncStatusGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the sync status for a connection.  Returns the most recent sync status from the state store.  If no sync has been run yet, a ``never_synced`` status is returned.
         * @summary Get Sync Status
         * @param {string} connectionId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSyncStatusApiV1ConnectorsConnectionIdSyncStatusGet_10(connectionId: string, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SyncStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSyncStatusApiV1ConnectorsConnectionIdSyncStatusGet_10(connectionId, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.getSyncStatusApiV1ConnectorsConnectionIdSyncStatusGet_10']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Handle OAuth callback and exchange code for tokens.
         * @summary Handle Oauth Callback
         * @param {string} connectorType 
         * @param {string} code 
         * @param {string} redirectUri 
         * @param {string | null} [state] 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleOauthCallbackApiV1ConnectorsConnectorTypeOauthCallbackPost(connectorType: string, code: string, redirectUri: string, state?: string | null, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleOauthCallbackApiV1ConnectorsConnectorTypeOauthCallbackPost(connectorType, code, redirectUri, state, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.handleOauthCallbackApiV1ConnectorsConnectorTypeOauthCallbackPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Handle OAuth callback and exchange code for tokens.
         * @summary Handle Oauth Callback
         * @param {string} connectorType 
         * @param {string} code 
         * @param {string} redirectUri 
         * @param {string | null} [state] 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleOauthCallbackApiV1ConnectorsConnectorTypeOauthCallbackPost_11(connectorType: string, code: string, redirectUri: string, state?: string | null, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleOauthCallbackApiV1ConnectorsConnectorTypeOauthCallbackPost_11(connectorType, code, redirectUri, state, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.handleOauthCallbackApiV1ConnectorsConnectorTypeOauthCallbackPost_11']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List files for a cloud storage connection.  Returns files and folders at the given *path* within the connected cloud storage provider.
         * @summary List Connection Files
         * @param {string} connectionId 
         * @param {string} [path] 
         * @param {boolean} [recursive] 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConnectionFilesApiV1ConnectorsConnectionIdFilesGet(connectionId: string, path?: string, recursive?: boolean, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listConnectionFilesApiV1ConnectorsConnectionIdFilesGet(connectionId, path, recursive, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.listConnectionFilesApiV1ConnectorsConnectionIdFilesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List files for a cloud storage connection.  Returns files and folders at the given *path* within the connected cloud storage provider.
         * @summary List Connection Files
         * @param {string} connectionId 
         * @param {string} [path] 
         * @param {boolean} [recursive] 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConnectionFilesApiV1ConnectorsConnectionIdFilesGet_12(connectionId: string, path?: string, recursive?: boolean, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listConnectionFilesApiV1ConnectorsConnectionIdFilesGet_12(connectionId, path, recursive, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.listConnectionFilesApiV1ConnectorsConnectionIdFilesGet_12']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List saved connections.
         * @summary List Connections
         * @param {string | null} [connectorType] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConnectionsApiV1ConnectorsGet(connectorType?: string | null, limit?: number, offset?: number, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listConnectionsApiV1ConnectorsGet(connectorType, limit, offset, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.listConnectionsApiV1ConnectorsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List saved connections.
         * @summary List Connections
         * @param {string | null} [connectorType] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConnectionsApiV1ConnectorsGet_13(connectorType?: string | null, limit?: number, offset?: number, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listConnectionsApiV1ConnectorsGet_13(connectorType, limit, offset, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.listConnectionsApiV1ConnectorsGet_13']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all available connector types.
         * @summary List Connector Types
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConnectorTypesApiV1ConnectorsTypesGet(xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConnectorInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listConnectorTypesApiV1ConnectorsTypesGet(xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.listConnectorTypesApiV1ConnectorsTypesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all available connector types.
         * @summary List Connector Types
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConnectorTypesApiV1ConnectorsTypesGet_14(xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConnectorInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listConnectorTypesApiV1ConnectorsTypesGet_14(xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.listConnectorTypesApiV1ConnectorsTypesGet_14']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List connectors by category.
         * @summary List Connectors By Category
         * @param {string} category 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConnectorsByCategoryApiV1ConnectorsTypesByCategoryCategoryGet(category: string, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConnectorInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listConnectorsByCategoryApiV1ConnectorsTypesByCategoryCategoryGet(category, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.listConnectorsByCategoryApiV1ConnectorsTypesByCategoryCategoryGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List connectors by category.
         * @summary List Connectors By Category
         * @param {string} category 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConnectorsByCategoryApiV1ConnectorsTypesByCategoryCategoryGet_15(category: string, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConnectorInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listConnectorsByCategoryApiV1ConnectorsTypesByCategoryCategoryGet_15(category, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.listConnectorsByCategoryApiV1ConnectorsTypesByCategoryCategoryGet_15']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Schedule periodic sync for a connection.  Stores the schedule configuration in the state store under ``connector_sync_status`` so that a background worker can pick it up.  The *interval_minutes* field must be between 5 and 1440 (24h).
         * @summary Schedule Connection Sync
         * @param {string} connectionId 
         * @param {SyncScheduleRequest} syncScheduleRequest 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scheduleConnectionSyncApiV1ConnectorsConnectionIdSyncSchedulePost(connectionId: string, syncScheduleRequest: SyncScheduleRequest, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SyncScheduleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scheduleConnectionSyncApiV1ConnectorsConnectionIdSyncSchedulePost(connectionId, syncScheduleRequest, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.scheduleConnectionSyncApiV1ConnectorsConnectionIdSyncSchedulePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Schedule periodic sync for a connection.  Stores the schedule configuration in the state store under ``connector_sync_status`` so that a background worker can pick it up.  The *interval_minutes* field must be between 5 and 1440 (24h).
         * @summary Schedule Connection Sync
         * @param {string} connectionId 
         * @param {SyncScheduleRequest} syncScheduleRequest 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scheduleConnectionSyncApiV1ConnectorsConnectionIdSyncSchedulePost_16(connectionId: string, syncScheduleRequest: SyncScheduleRequest, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SyncScheduleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scheduleConnectionSyncApiV1ConnectorsConnectionIdSyncSchedulePost_16(connectionId, syncScheduleRequest, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.scheduleConnectionSyncApiV1ConnectorsConnectionIdSyncSchedulePost_16']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Start syncing a connection.  Initiates a sync operation for the connection and records the sync status in the persistent state store under ``connector_sync_status``.
         * @summary Start Connection Sync
         * @param {string} connectionId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startConnectionSyncApiV1ConnectorsConnectionIdSyncPost(connectionId: string, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startConnectionSyncApiV1ConnectorsConnectionIdSyncPost(connectionId, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.startConnectionSyncApiV1ConnectorsConnectionIdSyncPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Start syncing a connection.  Initiates a sync operation for the connection and records the sync status in the persistent state store under ``connector_sync_status``.
         * @summary Start Connection Sync
         * @param {string} connectionId 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startConnectionSyncApiV1ConnectorsConnectionIdSyncPost_17(connectionId: string, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startConnectionSyncApiV1ConnectorsConnectionIdSyncPost_17(connectionId, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.startConnectionSyncApiV1ConnectorsConnectionIdSyncPost_17']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test a connection configuration.
         * @summary Test Connection
         * @param {string} connectorType 
         * @param {TestConnectionRequest} testConnectionRequest 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testConnectionApiV1ConnectorsConnectorTypeTestPost(connectorType: string, testConnectionRequest: TestConnectionRequest, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestConnectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testConnectionApiV1ConnectorsConnectorTypeTestPost(connectorType, testConnectionRequest, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.testConnectionApiV1ConnectorsConnectorTypeTestPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test a connection configuration.
         * @summary Test Connection
         * @param {string} connectorType 
         * @param {TestConnectionRequest} testConnectionRequest 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testConnectionApiV1ConnectorsConnectorTypeTestPost_18(connectorType: string, testConnectionRequest: TestConnectionRequest, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestConnectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testConnectionApiV1ConnectorsConnectorTypeTestPost_18(connectorType, testConnectionRequest, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.testConnectionApiV1ConnectorsConnectorTypeTestPost_18']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload a file to a cloud storage connection.  Accepts a multipart file upload and stores it at the given *path* within the connected cloud storage provider.
         * @summary Upload Connection File
         * @param {string} connectionId 
         * @param {File} file 
         * @param {string} [path] 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadConnectionFileApiV1ConnectorsConnectionIdFilesUploadPost(connectionId: string, file: File, path?: string, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileUploadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadConnectionFileApiV1ConnectorsConnectionIdFilesUploadPost(connectionId, file, path, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.uploadConnectionFileApiV1ConnectorsConnectionIdFilesUploadPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload a file to a cloud storage connection.  Accepts a multipart file upload and stores it at the given *path* within the connected cloud storage provider.
         * @summary Upload Connection File
         * @param {string} connectionId 
         * @param {File} file 
         * @param {string} [path] 
         * @param {string | null} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadConnectionFileApiV1ConnectorsConnectionIdFilesUploadPost_19(connectionId: string, file: File, path?: string, xApiKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileUploadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadConnectionFileApiV1ConnectorsConnectionIdFilesUploadPost_19(connectionId, file, path, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.uploadConnectionFileApiV1ConnectorsConnectionIdFilesUploadPost_19']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConnectorsApi - factory interface
 */
export const ConnectorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConnectorsApiFp(configuration)
    return {
        /**
         * Check if a connection is healthy.
         * @summary Check Connection Health
         * @param {ConnectorsApiCheckConnectionHealthApiV1ConnectorsConnectionIdHealthPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkConnectionHealthApiV1ConnectorsConnectionIdHealthPost(requestParameters: ConnectorsApiCheckConnectionHealthApiV1ConnectorsConnectionIdHealthPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<TestConnectionResponse> {
            return localVarFp.checkConnectionHealthApiV1ConnectorsConnectionIdHealthPost(requestParameters.connectionId, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if a connection is healthy.
         * @summary Check Connection Health
         * @param {ConnectorsApiCheckConnectionHealthApiV1ConnectorsConnectionIdHealthPost0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkConnectionHealthApiV1ConnectorsConnectionIdHealthPost_1(requestParameters: ConnectorsApiCheckConnectionHealthApiV1ConnectorsConnectionIdHealthPost0Request, options?: RawAxiosRequestConfig): AxiosPromise<TestConnectionResponse> {
            return localVarFp.checkConnectionHealthApiV1ConnectorsConnectionIdHealthPost_1(requestParameters.connectionId, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Create and save a new connection.
         * @summary Create Connection
         * @param {ConnectorsApiCreateConnectionApiV1ConnectorsConnectorTypeConnectPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnectionApiV1ConnectorsConnectorTypeConnectPost(requestParameters: ConnectorsApiCreateConnectionApiV1ConnectorsConnectorTypeConnectPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ConnectionResponse> {
            return localVarFp.createConnectionApiV1ConnectorsConnectorTypeConnectPost(requestParameters.connectorType, requestParameters.createConnectionRequest, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Create and save a new connection.
         * @summary Create Connection
         * @param {ConnectorsApiCreateConnectionApiV1ConnectorsConnectorTypeConnectPost0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnectionApiV1ConnectorsConnectorTypeConnectPost_2(requestParameters: ConnectorsApiCreateConnectionApiV1ConnectorsConnectorTypeConnectPost0Request, options?: RawAxiosRequestConfig): AxiosPromise<ConnectionResponse> {
            return localVarFp.createConnectionApiV1ConnectorsConnectorTypeConnectPost_2(requestParameters.connectorType, requestParameters.createConnectionRequest, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a connection.
         * @summary Delete Connection
         * @param {ConnectorsApiDeleteConnectionApiV1ConnectorsConnectionIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnectionApiV1ConnectorsConnectionIdDelete(requestParameters: ConnectorsApiDeleteConnectionApiV1ConnectorsConnectionIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.deleteConnectionApiV1ConnectorsConnectionIdDelete(requestParameters.connectionId, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a connection.
         * @summary Delete Connection
         * @param {ConnectorsApiDeleteConnectionApiV1ConnectorsConnectionIdDelete0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnectionApiV1ConnectorsConnectionIdDelete_3(requestParameters: ConnectorsApiDeleteConnectionApiV1ConnectorsConnectionIdDelete0Request, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.deleteConnectionApiV1ConnectorsConnectionIdDelete_3(requestParameters.connectionId, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Download a file from a cloud storage connection.  The *path* query parameter identifies the file to download.  The response streams the raw file bytes with an appropriate content type.
         * @summary Download Connection File
         * @param {ConnectorsApiDownloadConnectionFileApiV1ConnectorsConnectionIdFilesDownloadGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadConnectionFileApiV1ConnectorsConnectionIdFilesDownloadGet(requestParameters: ConnectorsApiDownloadConnectionFileApiV1ConnectorsConnectionIdFilesDownloadGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.downloadConnectionFileApiV1ConnectorsConnectionIdFilesDownloadGet(requestParameters.connectionId, requestParameters.path, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Download a file from a cloud storage connection.  The *path* query parameter identifies the file to download.  The response streams the raw file bytes with an appropriate content type.
         * @summary Download Connection File
         * @param {ConnectorsApiDownloadConnectionFileApiV1ConnectorsConnectionIdFilesDownloadGet0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadConnectionFileApiV1ConnectorsConnectionIdFilesDownloadGet_4(requestParameters: ConnectorsApiDownloadConnectionFileApiV1ConnectorsConnectionIdFilesDownloadGet0Request, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.downloadConnectionFileApiV1ConnectorsConnectionIdFilesDownloadGet_4(requestParameters.connectionId, requestParameters.path, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Execute a query on a connection.
         * @summary Execute Query
         * @param {ConnectorsApiExecuteQueryApiV1ConnectorsConnectionIdQueryPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeQueryApiV1ConnectorsConnectionIdQueryPost(requestParameters: ConnectorsApiExecuteQueryApiV1ConnectorsConnectionIdQueryPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<QueryResponse> {
            return localVarFp.executeQueryApiV1ConnectorsConnectionIdQueryPost(requestParameters.connectionId, requestParameters.queryRequest, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Execute a query on a connection.
         * @summary Execute Query
         * @param {ConnectorsApiExecuteQueryApiV1ConnectorsConnectionIdQueryPost0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeQueryApiV1ConnectorsConnectionIdQueryPost_5(requestParameters: ConnectorsApiExecuteQueryApiV1ConnectorsConnectionIdQueryPost0Request, options?: RawAxiosRequestConfig): AxiosPromise<QueryResponse> {
            return localVarFp.executeQueryApiV1ConnectorsConnectionIdQueryPost_5(requestParameters.connectionId, requestParameters.queryRequest, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a connection by ID.  Note: connection_id is restricted to UUID format to disambiguate from /{connector_type}/... routes which use short alphanumeric names.
         * @summary Get Connection
         * @param {ConnectorsApiGetConnectionApiV1ConnectorsConnectionIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionApiV1ConnectorsConnectionIdGet(requestParameters: ConnectorsApiGetConnectionApiV1ConnectorsConnectionIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ConnectionResponse> {
            return localVarFp.getConnectionApiV1ConnectorsConnectionIdGet(requestParameters.connectionId, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a connection by ID.  Note: connection_id is restricted to UUID format to disambiguate from /{connector_type}/... routes which use short alphanumeric names.
         * @summary Get Connection
         * @param {ConnectorsApiGetConnectionApiV1ConnectorsConnectionIdGet0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionApiV1ConnectorsConnectionIdGet_6(requestParameters: ConnectorsApiGetConnectionApiV1ConnectorsConnectionIdGet0Request, options?: RawAxiosRequestConfig): AxiosPromise<ConnectionResponse> {
            return localVarFp.getConnectionApiV1ConnectorsConnectionIdGet_6(requestParameters.connectionId, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get schema information for a connection.
         * @summary Get Connection Schema
         * @param {ConnectorsApiGetConnectionSchemaApiV1ConnectorsConnectionIdSchemaGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionSchemaApiV1ConnectorsConnectionIdSchemaGet(requestParameters: ConnectorsApiGetConnectionSchemaApiV1ConnectorsConnectionIdSchemaGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getConnectionSchemaApiV1ConnectorsConnectionIdSchemaGet(requestParameters.connectionId, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get schema information for a connection.
         * @summary Get Connection Schema
         * @param {ConnectorsApiGetConnectionSchemaApiV1ConnectorsConnectionIdSchemaGet0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionSchemaApiV1ConnectorsConnectionIdSchemaGet_7(requestParameters: ConnectorsApiGetConnectionSchemaApiV1ConnectorsConnectionIdSchemaGet0Request, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getConnectionSchemaApiV1ConnectorsConnectionIdSchemaGet_7(requestParameters.connectionId, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about a specific connector type.
         * @summary Get Connector Type
         * @param {ConnectorsApiGetConnectorTypeApiV1ConnectorsTypesConnectorTypeGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorTypeApiV1ConnectorsTypesConnectorTypeGet(requestParameters: ConnectorsApiGetConnectorTypeApiV1ConnectorsTypesConnectorTypeGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ConnectorInfo> {
            return localVarFp.getConnectorTypeApiV1ConnectorsTypesConnectorTypeGet(requestParameters.connectorType, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about a specific connector type.
         * @summary Get Connector Type
         * @param {ConnectorsApiGetConnectorTypeApiV1ConnectorsTypesConnectorTypeGet0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorTypeApiV1ConnectorsTypesConnectorTypeGet_8(requestParameters: ConnectorsApiGetConnectorTypeApiV1ConnectorsTypesConnectorTypeGet0Request, options?: RawAxiosRequestConfig): AxiosPromise<ConnectorInfo> {
            return localVarFp.getConnectorTypeApiV1ConnectorsTypesConnectorTypeGet_8(requestParameters.connectorType, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get OAuth authorization URL for a connector.
         * @summary Get Oauth Url
         * @param {ConnectorsApiGetOauthUrlApiV1ConnectorsConnectorTypeOauthAuthorizeGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOauthUrlApiV1ConnectorsConnectorTypeOauthAuthorizeGet(requestParameters: ConnectorsApiGetOauthUrlApiV1ConnectorsConnectorTypeOauthAuthorizeGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getOauthUrlApiV1ConnectorsConnectorTypeOauthAuthorizeGet(requestParameters.connectorType, requestParameters.redirectUri, requestParameters.state, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get OAuth authorization URL for a connector.
         * @summary Get Oauth Url
         * @param {ConnectorsApiGetOauthUrlApiV1ConnectorsConnectorTypeOauthAuthorizeGet0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOauthUrlApiV1ConnectorsConnectorTypeOauthAuthorizeGet_9(requestParameters: ConnectorsApiGetOauthUrlApiV1ConnectorsConnectorTypeOauthAuthorizeGet0Request, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getOauthUrlApiV1ConnectorsConnectorTypeOauthAuthorizeGet_9(requestParameters.connectorType, requestParameters.redirectUri, requestParameters.state, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the sync status for a connection.  Returns the most recent sync status from the state store.  If no sync has been run yet, a ``never_synced`` status is returned.
         * @summary Get Sync Status
         * @param {ConnectorsApiGetSyncStatusApiV1ConnectorsConnectionIdSyncStatusGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSyncStatusApiV1ConnectorsConnectionIdSyncStatusGet(requestParameters: ConnectorsApiGetSyncStatusApiV1ConnectorsConnectionIdSyncStatusGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<SyncStatusResponse> {
            return localVarFp.getSyncStatusApiV1ConnectorsConnectionIdSyncStatusGet(requestParameters.connectionId, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the sync status for a connection.  Returns the most recent sync status from the state store.  If no sync has been run yet, a ``never_synced`` status is returned.
         * @summary Get Sync Status
         * @param {ConnectorsApiGetSyncStatusApiV1ConnectorsConnectionIdSyncStatusGet0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSyncStatusApiV1ConnectorsConnectionIdSyncStatusGet_10(requestParameters: ConnectorsApiGetSyncStatusApiV1ConnectorsConnectionIdSyncStatusGet0Request, options?: RawAxiosRequestConfig): AxiosPromise<SyncStatusResponse> {
            return localVarFp.getSyncStatusApiV1ConnectorsConnectionIdSyncStatusGet_10(requestParameters.connectionId, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Handle OAuth callback and exchange code for tokens.
         * @summary Handle Oauth Callback
         * @param {ConnectorsApiHandleOauthCallbackApiV1ConnectorsConnectorTypeOauthCallbackPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleOauthCallbackApiV1ConnectorsConnectorTypeOauthCallbackPost(requestParameters: ConnectorsApiHandleOauthCallbackApiV1ConnectorsConnectorTypeOauthCallbackPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.handleOauthCallbackApiV1ConnectorsConnectorTypeOauthCallbackPost(requestParameters.connectorType, requestParameters.code, requestParameters.redirectUri, requestParameters.state, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Handle OAuth callback and exchange code for tokens.
         * @summary Handle Oauth Callback
         * @param {ConnectorsApiHandleOauthCallbackApiV1ConnectorsConnectorTypeOauthCallbackPost0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleOauthCallbackApiV1ConnectorsConnectorTypeOauthCallbackPost_11(requestParameters: ConnectorsApiHandleOauthCallbackApiV1ConnectorsConnectorTypeOauthCallbackPost0Request, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.handleOauthCallbackApiV1ConnectorsConnectorTypeOauthCallbackPost_11(requestParameters.connectorType, requestParameters.code, requestParameters.redirectUri, requestParameters.state, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * List files for a cloud storage connection.  Returns files and folders at the given *path* within the connected cloud storage provider.
         * @summary List Connection Files
         * @param {ConnectorsApiListConnectionFilesApiV1ConnectorsConnectionIdFilesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnectionFilesApiV1ConnectorsConnectionIdFilesGet(requestParameters: ConnectorsApiListConnectionFilesApiV1ConnectorsConnectionIdFilesGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.listConnectionFilesApiV1ConnectorsConnectionIdFilesGet(requestParameters.connectionId, requestParameters.path, requestParameters.recursive, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * List files for a cloud storage connection.  Returns files and folders at the given *path* within the connected cloud storage provider.
         * @summary List Connection Files
         * @param {ConnectorsApiListConnectionFilesApiV1ConnectorsConnectionIdFilesGet0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnectionFilesApiV1ConnectorsConnectionIdFilesGet_12(requestParameters: ConnectorsApiListConnectionFilesApiV1ConnectorsConnectionIdFilesGet0Request, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.listConnectionFilesApiV1ConnectorsConnectionIdFilesGet_12(requestParameters.connectionId, requestParameters.path, requestParameters.recursive, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * List saved connections.
         * @summary List Connections
         * @param {ConnectorsApiListConnectionsApiV1ConnectorsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnectionsApiV1ConnectorsGet(requestParameters: ConnectorsApiListConnectionsApiV1ConnectorsGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.listConnectionsApiV1ConnectorsGet(requestParameters.connectorType, requestParameters.limit, requestParameters.offset, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * List saved connections.
         * @summary List Connections
         * @param {ConnectorsApiListConnectionsApiV1ConnectorsGet0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnectionsApiV1ConnectorsGet_13(requestParameters: ConnectorsApiListConnectionsApiV1ConnectorsGet0Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.listConnectionsApiV1ConnectorsGet_13(requestParameters.connectorType, requestParameters.limit, requestParameters.offset, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * List all available connector types.
         * @summary List Connector Types
         * @param {ConnectorsApiListConnectorTypesApiV1ConnectorsTypesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnectorTypesApiV1ConnectorsTypesGet(requestParameters: ConnectorsApiListConnectorTypesApiV1ConnectorsTypesGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<ConnectorInfo>> {
            return localVarFp.listConnectorTypesApiV1ConnectorsTypesGet(requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * List all available connector types.
         * @summary List Connector Types
         * @param {ConnectorsApiListConnectorTypesApiV1ConnectorsTypesGet0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnectorTypesApiV1ConnectorsTypesGet_14(requestParameters: ConnectorsApiListConnectorTypesApiV1ConnectorsTypesGet0Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<ConnectorInfo>> {
            return localVarFp.listConnectorTypesApiV1ConnectorsTypesGet_14(requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * List connectors by category.
         * @summary List Connectors By Category
         * @param {ConnectorsApiListConnectorsByCategoryApiV1ConnectorsTypesByCategoryCategoryGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnectorsByCategoryApiV1ConnectorsTypesByCategoryCategoryGet(requestParameters: ConnectorsApiListConnectorsByCategoryApiV1ConnectorsTypesByCategoryCategoryGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ConnectorInfo>> {
            return localVarFp.listConnectorsByCategoryApiV1ConnectorsTypesByCategoryCategoryGet(requestParameters.category, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * List connectors by category.
         * @summary List Connectors By Category
         * @param {ConnectorsApiListConnectorsByCategoryApiV1ConnectorsTypesByCategoryCategoryGet0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnectorsByCategoryApiV1ConnectorsTypesByCategoryCategoryGet_15(requestParameters: ConnectorsApiListConnectorsByCategoryApiV1ConnectorsTypesByCategoryCategoryGet0Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<ConnectorInfo>> {
            return localVarFp.listConnectorsByCategoryApiV1ConnectorsTypesByCategoryCategoryGet_15(requestParameters.category, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Schedule periodic sync for a connection.  Stores the schedule configuration in the state store under ``connector_sync_status`` so that a background worker can pick it up.  The *interval_minutes* field must be between 5 and 1440 (24h).
         * @summary Schedule Connection Sync
         * @param {ConnectorsApiScheduleConnectionSyncApiV1ConnectorsConnectionIdSyncSchedulePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleConnectionSyncApiV1ConnectorsConnectionIdSyncSchedulePost(requestParameters: ConnectorsApiScheduleConnectionSyncApiV1ConnectorsConnectionIdSyncSchedulePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<SyncScheduleResponse> {
            return localVarFp.scheduleConnectionSyncApiV1ConnectorsConnectionIdSyncSchedulePost(requestParameters.connectionId, requestParameters.syncScheduleRequest, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Schedule periodic sync for a connection.  Stores the schedule configuration in the state store under ``connector_sync_status`` so that a background worker can pick it up.  The *interval_minutes* field must be between 5 and 1440 (24h).
         * @summary Schedule Connection Sync
         * @param {ConnectorsApiScheduleConnectionSyncApiV1ConnectorsConnectionIdSyncSchedulePost0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleConnectionSyncApiV1ConnectorsConnectionIdSyncSchedulePost_16(requestParameters: ConnectorsApiScheduleConnectionSyncApiV1ConnectorsConnectionIdSyncSchedulePost0Request, options?: RawAxiosRequestConfig): AxiosPromise<SyncScheduleResponse> {
            return localVarFp.scheduleConnectionSyncApiV1ConnectorsConnectionIdSyncSchedulePost_16(requestParameters.connectionId, requestParameters.syncScheduleRequest, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Start syncing a connection.  Initiates a sync operation for the connection and records the sync status in the persistent state store under ``connector_sync_status``.
         * @summary Start Connection Sync
         * @param {ConnectorsApiStartConnectionSyncApiV1ConnectorsConnectionIdSyncPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startConnectionSyncApiV1ConnectorsConnectionIdSyncPost(requestParameters: ConnectorsApiStartConnectionSyncApiV1ConnectorsConnectionIdSyncPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.startConnectionSyncApiV1ConnectorsConnectionIdSyncPost(requestParameters.connectionId, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Start syncing a connection.  Initiates a sync operation for the connection and records the sync status in the persistent state store under ``connector_sync_status``.
         * @summary Start Connection Sync
         * @param {ConnectorsApiStartConnectionSyncApiV1ConnectorsConnectionIdSyncPost0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startConnectionSyncApiV1ConnectorsConnectionIdSyncPost_17(requestParameters: ConnectorsApiStartConnectionSyncApiV1ConnectorsConnectionIdSyncPost0Request, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.startConnectionSyncApiV1ConnectorsConnectionIdSyncPost_17(requestParameters.connectionId, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Test a connection configuration.
         * @summary Test Connection
         * @param {ConnectorsApiTestConnectionApiV1ConnectorsConnectorTypeTestPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testConnectionApiV1ConnectorsConnectorTypeTestPost(requestParameters: ConnectorsApiTestConnectionApiV1ConnectorsConnectorTypeTestPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<TestConnectionResponse> {
            return localVarFp.testConnectionApiV1ConnectorsConnectorTypeTestPost(requestParameters.connectorType, requestParameters.testConnectionRequest, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Test a connection configuration.
         * @summary Test Connection
         * @param {ConnectorsApiTestConnectionApiV1ConnectorsConnectorTypeTestPost0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testConnectionApiV1ConnectorsConnectorTypeTestPost_18(requestParameters: ConnectorsApiTestConnectionApiV1ConnectorsConnectorTypeTestPost0Request, options?: RawAxiosRequestConfig): AxiosPromise<TestConnectionResponse> {
            return localVarFp.testConnectionApiV1ConnectorsConnectorTypeTestPost_18(requestParameters.connectorType, requestParameters.testConnectionRequest, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a file to a cloud storage connection.  Accepts a multipart file upload and stores it at the given *path* within the connected cloud storage provider.
         * @summary Upload Connection File
         * @param {ConnectorsApiUploadConnectionFileApiV1ConnectorsConnectionIdFilesUploadPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadConnectionFileApiV1ConnectorsConnectionIdFilesUploadPost(requestParameters: ConnectorsApiUploadConnectionFileApiV1ConnectorsConnectionIdFilesUploadPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<FileUploadResponse> {
            return localVarFp.uploadConnectionFileApiV1ConnectorsConnectionIdFilesUploadPost(requestParameters.connectionId, requestParameters.file, requestParameters.path, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a file to a cloud storage connection.  Accepts a multipart file upload and stores it at the given *path* within the connected cloud storage provider.
         * @summary Upload Connection File
         * @param {ConnectorsApiUploadConnectionFileApiV1ConnectorsConnectionIdFilesUploadPost0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadConnectionFileApiV1ConnectorsConnectionIdFilesUploadPost_19(requestParameters: ConnectorsApiUploadConnectionFileApiV1ConnectorsConnectionIdFilesUploadPost0Request, options?: RawAxiosRequestConfig): AxiosPromise<FileUploadResponse> {
            return localVarFp.uploadConnectionFileApiV1ConnectorsConnectionIdFilesUploadPost_19(requestParameters.connectionId, requestParameters.file, requestParameters.path, requestParameters.xApiKey, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for checkConnectionHealthApiV1ConnectorsConnectionIdHealthPost operation in ConnectorsApi.
 */
export interface ConnectorsApiCheckConnectionHealthApiV1ConnectorsConnectionIdHealthPostRequest {
    readonly connectionId: string

    readonly xApiKey?: string | null
}

/**
 * Request parameters for checkConnectionHealthApiV1ConnectorsConnectionIdHealthPost_1 operation in ConnectorsApi.
 */
export interface ConnectorsApiCheckConnectionHealthApiV1ConnectorsConnectionIdHealthPost0Request {
    readonly connectionId: string

    readonly xApiKey?: string | null
}

/**
 * Request parameters for createConnectionApiV1ConnectorsConnectorTypeConnectPost operation in ConnectorsApi.
 */
export interface ConnectorsApiCreateConnectionApiV1ConnectorsConnectorTypeConnectPostRequest {
    readonly connectorType: string

    readonly createConnectionRequest: CreateConnectionRequest

    readonly xApiKey?: string | null
}

/**
 * Request parameters for createConnectionApiV1ConnectorsConnectorTypeConnectPost_2 operation in ConnectorsApi.
 */
export interface ConnectorsApiCreateConnectionApiV1ConnectorsConnectorTypeConnectPost0Request {
    readonly connectorType: string

    readonly createConnectionRequest: CreateConnectionRequest

    readonly xApiKey?: string | null
}

/**
 * Request parameters for deleteConnectionApiV1ConnectorsConnectionIdDelete operation in ConnectorsApi.
 */
export interface ConnectorsApiDeleteConnectionApiV1ConnectorsConnectionIdDeleteRequest {
    readonly connectionId: string

    readonly xApiKey?: string | null
}

/**
 * Request parameters for deleteConnectionApiV1ConnectorsConnectionIdDelete_3 operation in ConnectorsApi.
 */
export interface ConnectorsApiDeleteConnectionApiV1ConnectorsConnectionIdDelete0Request {
    readonly connectionId: string

    readonly xApiKey?: string | null
}

/**
 * Request parameters for downloadConnectionFileApiV1ConnectorsConnectionIdFilesDownloadGet operation in ConnectorsApi.
 */
export interface ConnectorsApiDownloadConnectionFileApiV1ConnectorsConnectionIdFilesDownloadGetRequest {
    readonly connectionId: string

    readonly path: string

    readonly xApiKey?: string | null
}

/**
 * Request parameters for downloadConnectionFileApiV1ConnectorsConnectionIdFilesDownloadGet_4 operation in ConnectorsApi.
 */
export interface ConnectorsApiDownloadConnectionFileApiV1ConnectorsConnectionIdFilesDownloadGet0Request {
    readonly connectionId: string

    readonly path: string

    readonly xApiKey?: string | null
}

/**
 * Request parameters for executeQueryApiV1ConnectorsConnectionIdQueryPost operation in ConnectorsApi.
 */
export interface ConnectorsApiExecuteQueryApiV1ConnectorsConnectionIdQueryPostRequest {
    readonly connectionId: string

    readonly queryRequest: QueryRequest

    readonly xApiKey?: string | null
}

/**
 * Request parameters for executeQueryApiV1ConnectorsConnectionIdQueryPost_5 operation in ConnectorsApi.
 */
export interface ConnectorsApiExecuteQueryApiV1ConnectorsConnectionIdQueryPost0Request {
    readonly connectionId: string

    readonly queryRequest: QueryRequest

    readonly xApiKey?: string | null
}

/**
 * Request parameters for getConnectionApiV1ConnectorsConnectionIdGet operation in ConnectorsApi.
 */
export interface ConnectorsApiGetConnectionApiV1ConnectorsConnectionIdGetRequest {
    readonly connectionId: string

    readonly xApiKey?: string | null
}

/**
 * Request parameters for getConnectionApiV1ConnectorsConnectionIdGet_6 operation in ConnectorsApi.
 */
export interface ConnectorsApiGetConnectionApiV1ConnectorsConnectionIdGet0Request {
    readonly connectionId: string

    readonly xApiKey?: string | null
}

/**
 * Request parameters for getConnectionSchemaApiV1ConnectorsConnectionIdSchemaGet operation in ConnectorsApi.
 */
export interface ConnectorsApiGetConnectionSchemaApiV1ConnectorsConnectionIdSchemaGetRequest {
    readonly connectionId: string

    readonly xApiKey?: string | null
}

/**
 * Request parameters for getConnectionSchemaApiV1ConnectorsConnectionIdSchemaGet_7 operation in ConnectorsApi.
 */
export interface ConnectorsApiGetConnectionSchemaApiV1ConnectorsConnectionIdSchemaGet0Request {
    readonly connectionId: string

    readonly xApiKey?: string | null
}

/**
 * Request parameters for getConnectorTypeApiV1ConnectorsTypesConnectorTypeGet operation in ConnectorsApi.
 */
export interface ConnectorsApiGetConnectorTypeApiV1ConnectorsTypesConnectorTypeGetRequest {
    readonly connectorType: string

    readonly xApiKey?: string | null
}

/**
 * Request parameters for getConnectorTypeApiV1ConnectorsTypesConnectorTypeGet_8 operation in ConnectorsApi.
 */
export interface ConnectorsApiGetConnectorTypeApiV1ConnectorsTypesConnectorTypeGet0Request {
    readonly connectorType: string

    readonly xApiKey?: string | null
}

/**
 * Request parameters for getOauthUrlApiV1ConnectorsConnectorTypeOauthAuthorizeGet operation in ConnectorsApi.
 */
export interface ConnectorsApiGetOauthUrlApiV1ConnectorsConnectorTypeOauthAuthorizeGetRequest {
    readonly connectorType: string

    readonly redirectUri: string

    readonly state?: string | null

    readonly xApiKey?: string | null
}

/**
 * Request parameters for getOauthUrlApiV1ConnectorsConnectorTypeOauthAuthorizeGet_9 operation in ConnectorsApi.
 */
export interface ConnectorsApiGetOauthUrlApiV1ConnectorsConnectorTypeOauthAuthorizeGet0Request {
    readonly connectorType: string

    readonly redirectUri: string

    readonly state?: string | null

    readonly xApiKey?: string | null
}

/**
 * Request parameters for getSyncStatusApiV1ConnectorsConnectionIdSyncStatusGet operation in ConnectorsApi.
 */
export interface ConnectorsApiGetSyncStatusApiV1ConnectorsConnectionIdSyncStatusGetRequest {
    readonly connectionId: string

    readonly xApiKey?: string | null
}

/**
 * Request parameters for getSyncStatusApiV1ConnectorsConnectionIdSyncStatusGet_10 operation in ConnectorsApi.
 */
export interface ConnectorsApiGetSyncStatusApiV1ConnectorsConnectionIdSyncStatusGet0Request {
    readonly connectionId: string

    readonly xApiKey?: string | null
}

/**
 * Request parameters for handleOauthCallbackApiV1ConnectorsConnectorTypeOauthCallbackPost operation in ConnectorsApi.
 */
export interface ConnectorsApiHandleOauthCallbackApiV1ConnectorsConnectorTypeOauthCallbackPostRequest {
    readonly connectorType: string

    readonly code: string

    readonly redirectUri: string

    readonly state?: string | null

    readonly xApiKey?: string | null
}

/**
 * Request parameters for handleOauthCallbackApiV1ConnectorsConnectorTypeOauthCallbackPost_11 operation in ConnectorsApi.
 */
export interface ConnectorsApiHandleOauthCallbackApiV1ConnectorsConnectorTypeOauthCallbackPost0Request {
    readonly connectorType: string

    readonly code: string

    readonly redirectUri: string

    readonly state?: string | null

    readonly xApiKey?: string | null
}

/**
 * Request parameters for listConnectionFilesApiV1ConnectorsConnectionIdFilesGet operation in ConnectorsApi.
 */
export interface ConnectorsApiListConnectionFilesApiV1ConnectorsConnectionIdFilesGetRequest {
    readonly connectionId: string

    readonly path?: string

    readonly recursive?: boolean

    readonly xApiKey?: string | null
}

/**
 * Request parameters for listConnectionFilesApiV1ConnectorsConnectionIdFilesGet_12 operation in ConnectorsApi.
 */
export interface ConnectorsApiListConnectionFilesApiV1ConnectorsConnectionIdFilesGet0Request {
    readonly connectionId: string

    readonly path?: string

    readonly recursive?: boolean

    readonly xApiKey?: string | null
}

/**
 * Request parameters for listConnectionsApiV1ConnectorsGet operation in ConnectorsApi.
 */
export interface ConnectorsApiListConnectionsApiV1ConnectorsGetRequest {
    readonly connectorType?: string | null

    readonly limit?: number

    readonly offset?: number

    readonly xApiKey?: string | null
}

/**
 * Request parameters for listConnectionsApiV1ConnectorsGet_13 operation in ConnectorsApi.
 */
export interface ConnectorsApiListConnectionsApiV1ConnectorsGet0Request {
    readonly connectorType?: string | null

    readonly limit?: number

    readonly offset?: number

    readonly xApiKey?: string | null
}

/**
 * Request parameters for listConnectorTypesApiV1ConnectorsTypesGet operation in ConnectorsApi.
 */
export interface ConnectorsApiListConnectorTypesApiV1ConnectorsTypesGetRequest {
    readonly xApiKey?: string | null
}

/**
 * Request parameters for listConnectorTypesApiV1ConnectorsTypesGet_14 operation in ConnectorsApi.
 */
export interface ConnectorsApiListConnectorTypesApiV1ConnectorsTypesGet0Request {
    readonly xApiKey?: string | null
}

/**
 * Request parameters for listConnectorsByCategoryApiV1ConnectorsTypesByCategoryCategoryGet operation in ConnectorsApi.
 */
export interface ConnectorsApiListConnectorsByCategoryApiV1ConnectorsTypesByCategoryCategoryGetRequest {
    readonly category: string

    readonly xApiKey?: string | null
}

/**
 * Request parameters for listConnectorsByCategoryApiV1ConnectorsTypesByCategoryCategoryGet_15 operation in ConnectorsApi.
 */
export interface ConnectorsApiListConnectorsByCategoryApiV1ConnectorsTypesByCategoryCategoryGet0Request {
    readonly category: string

    readonly xApiKey?: string | null
}

/**
 * Request parameters for scheduleConnectionSyncApiV1ConnectorsConnectionIdSyncSchedulePost operation in ConnectorsApi.
 */
export interface ConnectorsApiScheduleConnectionSyncApiV1ConnectorsConnectionIdSyncSchedulePostRequest {
    readonly connectionId: string

    readonly syncScheduleRequest: SyncScheduleRequest

    readonly xApiKey?: string | null
}

/**
 * Request parameters for scheduleConnectionSyncApiV1ConnectorsConnectionIdSyncSchedulePost_16 operation in ConnectorsApi.
 */
export interface ConnectorsApiScheduleConnectionSyncApiV1ConnectorsConnectionIdSyncSchedulePost0Request {
    readonly connectionId: string

    readonly syncScheduleRequest: SyncScheduleRequest

    readonly xApiKey?: string | null
}

/**
 * Request parameters for startConnectionSyncApiV1ConnectorsConnectionIdSyncPost operation in ConnectorsApi.
 */
export interface ConnectorsApiStartConnectionSyncApiV1ConnectorsConnectionIdSyncPostRequest {
    readonly connectionId: string

    readonly xApiKey?: string | null
}

/**
 * Request parameters for startConnectionSyncApiV1ConnectorsConnectionIdSyncPost_17 operation in ConnectorsApi.
 */
export interface ConnectorsApiStartConnectionSyncApiV1ConnectorsConnectionIdSyncPost0Request {
    readonly connectionId: string

    readonly xApiKey?: string | null
}

/**
 * Request parameters for testConnectionApiV1ConnectorsConnectorTypeTestPost operation in ConnectorsApi.
 */
export interface ConnectorsApiTestConnectionApiV1ConnectorsConnectorTypeTestPostRequest {
    readonly connectorType: string

    readonly testConnectionRequest: TestConnectionRequest

    readonly xApiKey?: string | null
}

/**
 * Request parameters for testConnectionApiV1ConnectorsConnectorTypeTestPost_18 operation in ConnectorsApi.
 */
export interface ConnectorsApiTestConnectionApiV1ConnectorsConnectorTypeTestPost0Request {
    readonly connectorType: string

    readonly testConnectionRequest: TestConnectionRequest

    readonly xApiKey?: string | null
}

/**
 * Request parameters for uploadConnectionFileApiV1ConnectorsConnectionIdFilesUploadPost operation in ConnectorsApi.
 */
export interface ConnectorsApiUploadConnectionFileApiV1ConnectorsConnectionIdFilesUploadPostRequest {
    readonly connectionId: string

    readonly file: File

    readonly path?: string

    readonly xApiKey?: string | null
}

/**
 * Request parameters for uploadConnectionFileApiV1ConnectorsConnectionIdFilesUploadPost_19 operation in ConnectorsApi.
 */
export interface ConnectorsApiUploadConnectionFileApiV1ConnectorsConnectionIdFilesUploadPost0Request {
    readonly connectionId: string

    readonly file: File

    readonly path?: string

    readonly xApiKey?: string | null
}

/**
 * ConnectorsApi - object-oriented interface
 */
export class ConnectorsApi extends BaseAPI {
    /**
     * Check if a connection is healthy.
     * @summary Check Connection Health
     * @param {ConnectorsApiCheckConnectionHealthApiV1ConnectorsConnectionIdHealthPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public checkConnectionHealthApiV1ConnectorsConnectionIdHealthPost(requestParameters: ConnectorsApiCheckConnectionHealthApiV1ConnectorsConnectionIdHealthPostRequest, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).checkConnectionHealthApiV1ConnectorsConnectionIdHealthPost(requestParameters.connectionId, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if a connection is healthy.
     * @summary Check Connection Health
     * @param {ConnectorsApiCheckConnectionHealthApiV1ConnectorsConnectionIdHealthPost0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public checkConnectionHealthApiV1ConnectorsConnectionIdHealthPost_1(requestParameters: ConnectorsApiCheckConnectionHealthApiV1ConnectorsConnectionIdHealthPost0Request, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).checkConnectionHealthApiV1ConnectorsConnectionIdHealthPost_1(requestParameters.connectionId, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create and save a new connection.
     * @summary Create Connection
     * @param {ConnectorsApiCreateConnectionApiV1ConnectorsConnectorTypeConnectPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createConnectionApiV1ConnectorsConnectorTypeConnectPost(requestParameters: ConnectorsApiCreateConnectionApiV1ConnectorsConnectorTypeConnectPostRequest, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).createConnectionApiV1ConnectorsConnectorTypeConnectPost(requestParameters.connectorType, requestParameters.createConnectionRequest, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create and save a new connection.
     * @summary Create Connection
     * @param {ConnectorsApiCreateConnectionApiV1ConnectorsConnectorTypeConnectPost0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createConnectionApiV1ConnectorsConnectorTypeConnectPost_2(requestParameters: ConnectorsApiCreateConnectionApiV1ConnectorsConnectorTypeConnectPost0Request, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).createConnectionApiV1ConnectorsConnectorTypeConnectPost_2(requestParameters.connectorType, requestParameters.createConnectionRequest, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a connection.
     * @summary Delete Connection
     * @param {ConnectorsApiDeleteConnectionApiV1ConnectorsConnectionIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteConnectionApiV1ConnectorsConnectionIdDelete(requestParameters: ConnectorsApiDeleteConnectionApiV1ConnectorsConnectionIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).deleteConnectionApiV1ConnectorsConnectionIdDelete(requestParameters.connectionId, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a connection.
     * @summary Delete Connection
     * @param {ConnectorsApiDeleteConnectionApiV1ConnectorsConnectionIdDelete0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteConnectionApiV1ConnectorsConnectionIdDelete_3(requestParameters: ConnectorsApiDeleteConnectionApiV1ConnectorsConnectionIdDelete0Request, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).deleteConnectionApiV1ConnectorsConnectionIdDelete_3(requestParameters.connectionId, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Download a file from a cloud storage connection.  The *path* query parameter identifies the file to download.  The response streams the raw file bytes with an appropriate content type.
     * @summary Download Connection File
     * @param {ConnectorsApiDownloadConnectionFileApiV1ConnectorsConnectionIdFilesDownloadGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public downloadConnectionFileApiV1ConnectorsConnectionIdFilesDownloadGet(requestParameters: ConnectorsApiDownloadConnectionFileApiV1ConnectorsConnectionIdFilesDownloadGetRequest, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).downloadConnectionFileApiV1ConnectorsConnectionIdFilesDownloadGet(requestParameters.connectionId, requestParameters.path, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Download a file from a cloud storage connection.  The *path* query parameter identifies the file to download.  The response streams the raw file bytes with an appropriate content type.
     * @summary Download Connection File
     * @param {ConnectorsApiDownloadConnectionFileApiV1ConnectorsConnectionIdFilesDownloadGet0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public downloadConnectionFileApiV1ConnectorsConnectionIdFilesDownloadGet_4(requestParameters: ConnectorsApiDownloadConnectionFileApiV1ConnectorsConnectionIdFilesDownloadGet0Request, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).downloadConnectionFileApiV1ConnectorsConnectionIdFilesDownloadGet_4(requestParameters.connectionId, requestParameters.path, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Execute a query on a connection.
     * @summary Execute Query
     * @param {ConnectorsApiExecuteQueryApiV1ConnectorsConnectionIdQueryPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public executeQueryApiV1ConnectorsConnectionIdQueryPost(requestParameters: ConnectorsApiExecuteQueryApiV1ConnectorsConnectionIdQueryPostRequest, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).executeQueryApiV1ConnectorsConnectionIdQueryPost(requestParameters.connectionId, requestParameters.queryRequest, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Execute a query on a connection.
     * @summary Execute Query
     * @param {ConnectorsApiExecuteQueryApiV1ConnectorsConnectionIdQueryPost0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public executeQueryApiV1ConnectorsConnectionIdQueryPost_5(requestParameters: ConnectorsApiExecuteQueryApiV1ConnectorsConnectionIdQueryPost0Request, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).executeQueryApiV1ConnectorsConnectionIdQueryPost_5(requestParameters.connectionId, requestParameters.queryRequest, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a connection by ID.  Note: connection_id is restricted to UUID format to disambiguate from /{connector_type}/... routes which use short alphanumeric names.
     * @summary Get Connection
     * @param {ConnectorsApiGetConnectionApiV1ConnectorsConnectionIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getConnectionApiV1ConnectorsConnectionIdGet(requestParameters: ConnectorsApiGetConnectionApiV1ConnectorsConnectionIdGetRequest, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).getConnectionApiV1ConnectorsConnectionIdGet(requestParameters.connectionId, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a connection by ID.  Note: connection_id is restricted to UUID format to disambiguate from /{connector_type}/... routes which use short alphanumeric names.
     * @summary Get Connection
     * @param {ConnectorsApiGetConnectionApiV1ConnectorsConnectionIdGet0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getConnectionApiV1ConnectorsConnectionIdGet_6(requestParameters: ConnectorsApiGetConnectionApiV1ConnectorsConnectionIdGet0Request, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).getConnectionApiV1ConnectorsConnectionIdGet_6(requestParameters.connectionId, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get schema information for a connection.
     * @summary Get Connection Schema
     * @param {ConnectorsApiGetConnectionSchemaApiV1ConnectorsConnectionIdSchemaGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getConnectionSchemaApiV1ConnectorsConnectionIdSchemaGet(requestParameters: ConnectorsApiGetConnectionSchemaApiV1ConnectorsConnectionIdSchemaGetRequest, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).getConnectionSchemaApiV1ConnectorsConnectionIdSchemaGet(requestParameters.connectionId, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get schema information for a connection.
     * @summary Get Connection Schema
     * @param {ConnectorsApiGetConnectionSchemaApiV1ConnectorsConnectionIdSchemaGet0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getConnectionSchemaApiV1ConnectorsConnectionIdSchemaGet_7(requestParameters: ConnectorsApiGetConnectionSchemaApiV1ConnectorsConnectionIdSchemaGet0Request, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).getConnectionSchemaApiV1ConnectorsConnectionIdSchemaGet_7(requestParameters.connectionId, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about a specific connector type.
     * @summary Get Connector Type
     * @param {ConnectorsApiGetConnectorTypeApiV1ConnectorsTypesConnectorTypeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getConnectorTypeApiV1ConnectorsTypesConnectorTypeGet(requestParameters: ConnectorsApiGetConnectorTypeApiV1ConnectorsTypesConnectorTypeGetRequest, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).getConnectorTypeApiV1ConnectorsTypesConnectorTypeGet(requestParameters.connectorType, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about a specific connector type.
     * @summary Get Connector Type
     * @param {ConnectorsApiGetConnectorTypeApiV1ConnectorsTypesConnectorTypeGet0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getConnectorTypeApiV1ConnectorsTypesConnectorTypeGet_8(requestParameters: ConnectorsApiGetConnectorTypeApiV1ConnectorsTypesConnectorTypeGet0Request, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).getConnectorTypeApiV1ConnectorsTypesConnectorTypeGet_8(requestParameters.connectorType, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get OAuth authorization URL for a connector.
     * @summary Get Oauth Url
     * @param {ConnectorsApiGetOauthUrlApiV1ConnectorsConnectorTypeOauthAuthorizeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getOauthUrlApiV1ConnectorsConnectorTypeOauthAuthorizeGet(requestParameters: ConnectorsApiGetOauthUrlApiV1ConnectorsConnectorTypeOauthAuthorizeGetRequest, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).getOauthUrlApiV1ConnectorsConnectorTypeOauthAuthorizeGet(requestParameters.connectorType, requestParameters.redirectUri, requestParameters.state, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get OAuth authorization URL for a connector.
     * @summary Get Oauth Url
     * @param {ConnectorsApiGetOauthUrlApiV1ConnectorsConnectorTypeOauthAuthorizeGet0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getOauthUrlApiV1ConnectorsConnectorTypeOauthAuthorizeGet_9(requestParameters: ConnectorsApiGetOauthUrlApiV1ConnectorsConnectorTypeOauthAuthorizeGet0Request, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).getOauthUrlApiV1ConnectorsConnectorTypeOauthAuthorizeGet_9(requestParameters.connectorType, requestParameters.redirectUri, requestParameters.state, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the sync status for a connection.  Returns the most recent sync status from the state store.  If no sync has been run yet, a ``never_synced`` status is returned.
     * @summary Get Sync Status
     * @param {ConnectorsApiGetSyncStatusApiV1ConnectorsConnectionIdSyncStatusGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSyncStatusApiV1ConnectorsConnectionIdSyncStatusGet(requestParameters: ConnectorsApiGetSyncStatusApiV1ConnectorsConnectionIdSyncStatusGetRequest, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).getSyncStatusApiV1ConnectorsConnectionIdSyncStatusGet(requestParameters.connectionId, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the sync status for a connection.  Returns the most recent sync status from the state store.  If no sync has been run yet, a ``never_synced`` status is returned.
     * @summary Get Sync Status
     * @param {ConnectorsApiGetSyncStatusApiV1ConnectorsConnectionIdSyncStatusGet0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSyncStatusApiV1ConnectorsConnectionIdSyncStatusGet_10(requestParameters: ConnectorsApiGetSyncStatusApiV1ConnectorsConnectionIdSyncStatusGet0Request, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).getSyncStatusApiV1ConnectorsConnectionIdSyncStatusGet_10(requestParameters.connectionId, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Handle OAuth callback and exchange code for tokens.
     * @summary Handle Oauth Callback
     * @param {ConnectorsApiHandleOauthCallbackApiV1ConnectorsConnectorTypeOauthCallbackPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public handleOauthCallbackApiV1ConnectorsConnectorTypeOauthCallbackPost(requestParameters: ConnectorsApiHandleOauthCallbackApiV1ConnectorsConnectorTypeOauthCallbackPostRequest, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).handleOauthCallbackApiV1ConnectorsConnectorTypeOauthCallbackPost(requestParameters.connectorType, requestParameters.code, requestParameters.redirectUri, requestParameters.state, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Handle OAuth callback and exchange code for tokens.
     * @summary Handle Oauth Callback
     * @param {ConnectorsApiHandleOauthCallbackApiV1ConnectorsConnectorTypeOauthCallbackPost0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public handleOauthCallbackApiV1ConnectorsConnectorTypeOauthCallbackPost_11(requestParameters: ConnectorsApiHandleOauthCallbackApiV1ConnectorsConnectorTypeOauthCallbackPost0Request, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).handleOauthCallbackApiV1ConnectorsConnectorTypeOauthCallbackPost_11(requestParameters.connectorType, requestParameters.code, requestParameters.redirectUri, requestParameters.state, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List files for a cloud storage connection.  Returns files and folders at the given *path* within the connected cloud storage provider.
     * @summary List Connection Files
     * @param {ConnectorsApiListConnectionFilesApiV1ConnectorsConnectionIdFilesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listConnectionFilesApiV1ConnectorsConnectionIdFilesGet(requestParameters: ConnectorsApiListConnectionFilesApiV1ConnectorsConnectionIdFilesGetRequest, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).listConnectionFilesApiV1ConnectorsConnectionIdFilesGet(requestParameters.connectionId, requestParameters.path, requestParameters.recursive, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List files for a cloud storage connection.  Returns files and folders at the given *path* within the connected cloud storage provider.
     * @summary List Connection Files
     * @param {ConnectorsApiListConnectionFilesApiV1ConnectorsConnectionIdFilesGet0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listConnectionFilesApiV1ConnectorsConnectionIdFilesGet_12(requestParameters: ConnectorsApiListConnectionFilesApiV1ConnectorsConnectionIdFilesGet0Request, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).listConnectionFilesApiV1ConnectorsConnectionIdFilesGet_12(requestParameters.connectionId, requestParameters.path, requestParameters.recursive, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List saved connections.
     * @summary List Connections
     * @param {ConnectorsApiListConnectionsApiV1ConnectorsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listConnectionsApiV1ConnectorsGet(requestParameters: ConnectorsApiListConnectionsApiV1ConnectorsGetRequest = {}, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).listConnectionsApiV1ConnectorsGet(requestParameters.connectorType, requestParameters.limit, requestParameters.offset, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List saved connections.
     * @summary List Connections
     * @param {ConnectorsApiListConnectionsApiV1ConnectorsGet0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listConnectionsApiV1ConnectorsGet_13(requestParameters: ConnectorsApiListConnectionsApiV1ConnectorsGet0Request = {}, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).listConnectionsApiV1ConnectorsGet_13(requestParameters.connectorType, requestParameters.limit, requestParameters.offset, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all available connector types.
     * @summary List Connector Types
     * @param {ConnectorsApiListConnectorTypesApiV1ConnectorsTypesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listConnectorTypesApiV1ConnectorsTypesGet(requestParameters: ConnectorsApiListConnectorTypesApiV1ConnectorsTypesGetRequest = {}, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).listConnectorTypesApiV1ConnectorsTypesGet(requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all available connector types.
     * @summary List Connector Types
     * @param {ConnectorsApiListConnectorTypesApiV1ConnectorsTypesGet0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listConnectorTypesApiV1ConnectorsTypesGet_14(requestParameters: ConnectorsApiListConnectorTypesApiV1ConnectorsTypesGet0Request = {}, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).listConnectorTypesApiV1ConnectorsTypesGet_14(requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List connectors by category.
     * @summary List Connectors By Category
     * @param {ConnectorsApiListConnectorsByCategoryApiV1ConnectorsTypesByCategoryCategoryGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listConnectorsByCategoryApiV1ConnectorsTypesByCategoryCategoryGet(requestParameters: ConnectorsApiListConnectorsByCategoryApiV1ConnectorsTypesByCategoryCategoryGetRequest, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).listConnectorsByCategoryApiV1ConnectorsTypesByCategoryCategoryGet(requestParameters.category, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List connectors by category.
     * @summary List Connectors By Category
     * @param {ConnectorsApiListConnectorsByCategoryApiV1ConnectorsTypesByCategoryCategoryGet0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listConnectorsByCategoryApiV1ConnectorsTypesByCategoryCategoryGet_15(requestParameters: ConnectorsApiListConnectorsByCategoryApiV1ConnectorsTypesByCategoryCategoryGet0Request, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).listConnectorsByCategoryApiV1ConnectorsTypesByCategoryCategoryGet_15(requestParameters.category, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Schedule periodic sync for a connection.  Stores the schedule configuration in the state store under ``connector_sync_status`` so that a background worker can pick it up.  The *interval_minutes* field must be between 5 and 1440 (24h).
     * @summary Schedule Connection Sync
     * @param {ConnectorsApiScheduleConnectionSyncApiV1ConnectorsConnectionIdSyncSchedulePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public scheduleConnectionSyncApiV1ConnectorsConnectionIdSyncSchedulePost(requestParameters: ConnectorsApiScheduleConnectionSyncApiV1ConnectorsConnectionIdSyncSchedulePostRequest, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).scheduleConnectionSyncApiV1ConnectorsConnectionIdSyncSchedulePost(requestParameters.connectionId, requestParameters.syncScheduleRequest, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Schedule periodic sync for a connection.  Stores the schedule configuration in the state store under ``connector_sync_status`` so that a background worker can pick it up.  The *interval_minutes* field must be between 5 and 1440 (24h).
     * @summary Schedule Connection Sync
     * @param {ConnectorsApiScheduleConnectionSyncApiV1ConnectorsConnectionIdSyncSchedulePost0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public scheduleConnectionSyncApiV1ConnectorsConnectionIdSyncSchedulePost_16(requestParameters: ConnectorsApiScheduleConnectionSyncApiV1ConnectorsConnectionIdSyncSchedulePost0Request, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).scheduleConnectionSyncApiV1ConnectorsConnectionIdSyncSchedulePost_16(requestParameters.connectionId, requestParameters.syncScheduleRequest, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start syncing a connection.  Initiates a sync operation for the connection and records the sync status in the persistent state store under ``connector_sync_status``.
     * @summary Start Connection Sync
     * @param {ConnectorsApiStartConnectionSyncApiV1ConnectorsConnectionIdSyncPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public startConnectionSyncApiV1ConnectorsConnectionIdSyncPost(requestParameters: ConnectorsApiStartConnectionSyncApiV1ConnectorsConnectionIdSyncPostRequest, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).startConnectionSyncApiV1ConnectorsConnectionIdSyncPost(requestParameters.connectionId, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start syncing a connection.  Initiates a sync operation for the connection and records the sync status in the persistent state store under ``connector_sync_status``.
     * @summary Start Connection Sync
     * @param {ConnectorsApiStartConnectionSyncApiV1ConnectorsConnectionIdSyncPost0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public startConnectionSyncApiV1ConnectorsConnectionIdSyncPost_17(requestParameters: ConnectorsApiStartConnectionSyncApiV1ConnectorsConnectionIdSyncPost0Request, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).startConnectionSyncApiV1ConnectorsConnectionIdSyncPost_17(requestParameters.connectionId, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test a connection configuration.
     * @summary Test Connection
     * @param {ConnectorsApiTestConnectionApiV1ConnectorsConnectorTypeTestPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public testConnectionApiV1ConnectorsConnectorTypeTestPost(requestParameters: ConnectorsApiTestConnectionApiV1ConnectorsConnectorTypeTestPostRequest, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).testConnectionApiV1ConnectorsConnectorTypeTestPost(requestParameters.connectorType, requestParameters.testConnectionRequest, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test a connection configuration.
     * @summary Test Connection
     * @param {ConnectorsApiTestConnectionApiV1ConnectorsConnectorTypeTestPost0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public testConnectionApiV1ConnectorsConnectorTypeTestPost_18(requestParameters: ConnectorsApiTestConnectionApiV1ConnectorsConnectorTypeTestPost0Request, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).testConnectionApiV1ConnectorsConnectorTypeTestPost_18(requestParameters.connectorType, requestParameters.testConnectionRequest, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload a file to a cloud storage connection.  Accepts a multipart file upload and stores it at the given *path* within the connected cloud storage provider.
     * @summary Upload Connection File
     * @param {ConnectorsApiUploadConnectionFileApiV1ConnectorsConnectionIdFilesUploadPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public uploadConnectionFileApiV1ConnectorsConnectionIdFilesUploadPost(requestParameters: ConnectorsApiUploadConnectionFileApiV1ConnectorsConnectionIdFilesUploadPostRequest, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).uploadConnectionFileApiV1ConnectorsConnectionIdFilesUploadPost(requestParameters.connectionId, requestParameters.file, requestParameters.path, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload a file to a cloud storage connection.  Accepts a multipart file upload and stores it at the given *path* within the connected cloud storage provider.
     * @summary Upload Connection File
     * @param {ConnectorsApiUploadConnectionFileApiV1ConnectorsConnectionIdFilesUploadPost0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public uploadConnectionFileApiV1ConnectorsConnectionIdFilesUploadPost_19(requestParameters: ConnectorsApiUploadConnectionFileApiV1ConnectorsConnectionIdFilesUploadPost0Request, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).uploadConnectionFileApiV1ConnectorsConnectionIdFilesUploadPost_19(requestParameters.connectionId, requestParameters.file, requestParameters.path, requestParameters.xApiKey, options).then((request) => request(this.axios, this.basePath));
    }
}

